🧩 任务名称

Google OAuth redirect_uri_mismatch + TLS 安全告警 最终修复（v4，含代码精简）

🎯 本次 v4 目标（给 Cursor）

彻底收紧配置源：AUTH_URL / NEXTAUTH_URL 只保留一套清晰逻辑，删除所有历史回退/备选路径和无用日志。

移除冗余/过时代码：

删除 v1/v2/v3 残留的无用调试代码、重复日志、未再使用的辅助函数。

保证 env/auth 模块结构简洁、职责单一。

对 TLS 错误做强约束：

在生产环境中，如果检测到 NODE_TLS_REJECT_UNAUTHORIZED=0，直接 fail-fast 抛错，阻止应用在不安全配置下运行，而不是只打一条警告。

确认项目代码中没有任何地方去设置/修改 NODE_TLS_REJECT_UNAUTHORIZED。

收敛 redirect_uri 逻辑：

确认项目中不再有任何手动写死 redirect_uri / 错误域名的代码。

保证只有一条、明确可读的逻辑生成 https://ai.zalem.app/api/auth/callback/google。

文档与执行报告同步：

在 v3 文档基础上，加一层「v4：精简+安全收口」说明。

标明「今后遇到 redirect_uri / TLS 问题，优先检查统一入口 + 环境变量」。

🗂 涉及文件范围

以 v3 执行报告中列出的文件为基础，做「增量 + 精简」修改：

配置 & 认证模块

src/lib/env.ts

src/lib/auth.ts

src/app/api/auth/[...nextauth]/route.ts（如果存在）

诊断接口（保留但瘦身）

src/app/api/auth/debug/google-redirect/route.ts

文档 & 执行报告

docs/问题修复/Google_OAuth_redirect_uri_mismatch错误/修复指南.md

docs/问题修复/Google_OAuth_redirect_uri_mismatch错误/快速检查清单.md

docs/问题修复/2025-11-27/Google_OAuth_redirect_uri_mismatch错误/执行报告/v3_执行报告.md（在其基础上追加 v4 小节）

A. 全局清理：删除冗余和历史调试代码
A1. 搜索 & 删除手动 redirect_uri

操作（必须执行）：

全局搜索以下关键字（例如用 ripgrep）：

redirect_uri

redirectUrl

callbackUrl（注意大小写）

检查所有匹配：

如果是在 GoogleProvider / NextAuth 配置里显式设置 redirectUri，一律删除，让 Auth.js 自己根据 AUTH_URL 生成。

如果是历史调试代码中构造了「模拟用的 redirect_uri」但不再使用，也一律删除或合并进唯一诊断入口。

目标：

最终项目中 不再有 手动配置 redirectUri 的 Provider 配置。
所有关于 Google callback 地址的字符串，只出现在：

getAuthBaseUrl() 返回值拼接 /api/auth/callback/google；

debug 接口中只读展示。

A2. 搜索 & 删除 VERCEL_URL / 其他 URL 回退逻辑

全局搜索：

VERCEL_URL

AUTH_URL ||

NEXTAUTH_URL ||（注意那些「多级 or 回退」写法）

对于 env.ts / auth.ts 中仍存在的回退逻辑，统一改为：

唯一来源：NEXTAUTH_URL（由我们校验并同步给 AUTH_URL）。

不再从 VERCEL_URL / process.env.URL / 任意请求 Host 推导 base URL。

具体要求：

在 src/lib/env.ts 中保留一条清晰逻辑：

// 伪代码结构示意（Cursor 用实际代码实现）：
const isProd = process.env.NODE_ENV === "production";

export function getAuthBaseUrl(): string {
  const nextAuthUrl = process.env.NEXTAUTH_URL;
  const authUrl = process.env.AUTH_URL ?? nextAuthUrl;

  // 只Allow一个来源，不再有多层回退
  const base = authUrl ?? (isProd ? null : "http://localhost:3000");

  // 生产环境：base 为空 -> throw
  // base 必须 https / 无尾斜杠 -> 否则 throw
  // 开发环境：可以是 http，打印 warning 即可

  return base;
}


模块加载时的同步逻辑可以保留，但简化：

if (process.env.NEXTAUTH_URL && !process.env.AUTH_URL) {
  process.env.AUTH_URL = process.env.NEXTAUTH_URL;
}


删除所有关于 VERCEL_URL 的访问和日志，只在文档中保留历史说明即可。

A3. 精简 env/auth 日志（保留必要的两三条）

当前 v1–v3 叠加后，env.ts / auth.ts 日志可能较多。请做一次整理：

保留这些关键日志：

启动时的配置快照（1 条）：

[NextAuth][Config] NODE_ENV=..., NEXTAUTH_URL=..., AUTH_URL=..., AUTH_TRUST_HOST=...

Google Provider 的预期回调地址（1 条）：

[NextAuth][Google] expected redirect_uri: ${authBaseUrl}/api/auth/callback/google

删除或合并其他零散日志：

例如重复输出的「使用的 Auth URL」等信息，合并进一条更完整的行。

文本中不要再提 v1/v2 的「VERCEL_URL 回退方案」。

目标：

env/auth 两个文件里，和 URL 相关的日志不超过 3 条，语义清晰、不重复。

B. TLS 配置：对 NODE_TLS_REJECT_UNAUTHORIZED=0 做强约束
B1. 确认代码中没有主动设置 NODE_TLS_REJECT_UNAUTHORIZED

全局搜索：

NODE_TLS_REJECT_UNAUTHORIZED

要求：

项目中 不允许 有任何代码行类似：

process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'

process.env.NODE_TLS_REJECT_UNAUTHORIZED = '1'

如果发现此类代码，一律删除。

B2. 在 env.ts 中添加生产环境强校验（fail-fast）

文件：src/lib/env.ts

在模块顶层（或者在 getAuthBaseUrl() 较早的地方），增加生产环境的强制校验：

// 伪代码示意，Cursor 写成实际 TypeScript：

const isProd = process.env.NODE_ENV === "production";

if (isProd && process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0") {
  throw new Error(
    "[Security][FATAL] NODE_TLS_REJECT_UNAUTHORIZED=0 detected in production. " +
    "This disables TLS certificate verification and is strictly forbidden. " +
    "Please remove NODE_TLS_REJECT_UNAUTHORIZED from the environment variables on Vercel.",
  );
}


说明：

这不是“无用代码”，而是 安全红线：

只在 NODE_ENV === "production" 时启用。

一旦发现配置为 0，直接阻止服务启动，避免你在不知情情况下跑在极不安全环境里。

日志中的那条 warning 来自 Node 核心，在我们加上这个 guard 后，服务根本起不来，就不会再看到这条 warning（前提是你把 Vercel 那个 env 删掉）。

C. redirect_uri 自检与唯一真相来源
C1. 保留并瘦身 debug 接口

文件：src/app/api/auth/debug/google-redirect/route.ts

目标：只保留对你真正有用的信息，删除冗余字段。

返回内容仅包含：

{
  "NODE_ENV": "...",
  "baseUrl": "...",
  "expectedRedirectUri": "...",
  "note": "..."
}


具体字段建议：

NODE_ENV

baseUrl（即 getAuthBaseUrl() 返回值）

expectedRedirectUri（baseUrl + "/api/auth/callback/google"）

note 简短说明：「请在 Google Cloud Console 中精确配置 expectedRedirectUri」。

删除不必要的环境变量回显（如 AUTH_TRUST_HOST 如果你已经不怎么用来调试，可以去掉；保留也可以，但注意不要再把一堆东西都吐出来）。

目的：

这个接口成为你人肉调试 Google 配置的 唯一入口；
不再有多处计算 redirect_uri 的代码。

C2. NextAuth 路由中只依赖 getAuthBaseUrl

如果存在 src/app/api/auth/[...nextauth]/route.ts：

确认此文件中 没有手动拼接域名；

配置形如：

import NextAuth from "next-auth";
import { authConfig } from "@/src/lib/auth";

const { auth, handlers } = NextAuth(authConfig);

export { handlers as GET, handlers as POST };


base URL 逻辑一律集中在 src/lib/env.ts + src/lib/auth.ts，路由仅负责挂载。

D. 文档 & 执行报告：v4 收口说明
D1. 修复指南 / 快速检查清单

文件：

docs/问题修复/Google_OAuth_redirect_uri_mismatch错误/修复指南.md

docs/问题修复/Google_OAuth_redirect_uri_mismatch错误/快速检查清单.md

在现有 v3 说明基础上，追加「v4 补充」小节：

新增检查项（快速检查清单）：

 生产环境未设置 NODE_TLS_REJECT_UNAUTHORIZED=0，否则服务启动即失败。

 代码中没有任何 redirectUri 手动配置项。

 访问 /api/auth/debug/google-redirect 时，expectedRedirectUri 为：

https://ai.zalem.app/api/auth/callback/google。

新增建议（修复指南）：

指明今后所有 URL 相关问题，都从 getAuthBaseUrl() + debug 接口入手排查；

显式写出「只允许 NEXTAUTH_URL 作为唯一来源，禁止再使用 VERCEL_URL 回退逻辑」。

D2. v3_执行报告 中追加 v4 小节

文件：docs/问题修复/2025-11-27/Google_OAuth_redirect_uri_mismatch错误/执行报告/v3_执行报告.md

在结尾追加「v4 后续修改摘要」：

简述：

删除了历史回退逻辑和冗余日志；

在生产环境对 NODE_TLS_REJECT_UNAUTHORIZED=0 进行 fail-fast 校验；

统一了 redirect_uri 计算逻辑，仅保留 debug 接口作为对外观测窗口。

声明：

自 v4 起，任何在生产环境看到的 redirect_uri_mismatch / TLS 相关报错，都应优先检查：

Vercel 环境变量；

debug 接口返回的 expectedRedirectUri；

Google 控制台的 Authorized redirect URIs。

E. 最终验收标准（Cursor 写进新的 v4 执行报告）

请 Cursor 在新的 v4_执行报告.md 中，明确给出：

代码层面：

 全局无 redirectUri 手动配置；

 全局无 VERCEL_URL 参与 OAuth base URL 计算；

 生产环境如存在 NODE_TLS_REJECT_UNAUTHORIZED=0，应用启动会直接抛错。

诊断接口：

访问生产地址 /api/auth/debug/google-redirect 时，返回：

baseUrl = "https://ai.zalem.app"

expectedRedirectUri = "https://ai.zalem.app/api/auth/callback/google"

Google 控制台（你自己检查，Cursor 在报告中引用你的描述）：

Authorized redirect URIs 中确实包含上面的 expectedRedirectUri，且没有 typo / 多余斜杠。

Google 登录测试结果：

在 https://ai.zalem.app 上点击 Google 登录，不再出现 redirect_uri_mismatch。