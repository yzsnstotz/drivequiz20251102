✅ 给 Cursor 的一次性修复指令（AdapterError 专项 · v1）

注意：本任务只针对 NextAuth 适配器层/数据库层，
禁止 修改 ai-service、drivequiz-api 等其他服务。

1. 识别当前使用的 Adapter 类型

步骤 1.1：查找 NextAuth 配置

在仓库中找到 NextAuth 配置文件（根据现有结构，优先查）：

src/lib/auth.ts

或 apps/web/src/lib/auth.ts / apps/web/src/server/auth.ts 等路径

确定导出类似：

import NextAuth from "next-auth";

export const { auth, handlers, signIn, signOut } = NextAuth({
  // ...
  adapter: XXX,
  providers: [/* line, twitter/x, google 等 */],
  // ...
});


步骤 1.2：确定 Adapter 类型分支

根据 adapter 的来源，分三种情况处理：

PrismaAdapter 分支

import { PrismaAdapter } from "@auth/prisma-adapter";

或类似从 @next-auth/prisma-adapter 引入。

SupabaseAdapter 分支

import { SupabaseAdapter } from "@auth/supabase-adapter";

或项目中有 createClient(supabaseUrl, supabaseKey) 并作为 Adapter 传入。

自定义 Adapter 分支

存在 const myAdapter: Adapter = { ... } 这种实现，文件名可能类似 src/lib/nextAuthAdapter.ts 或 src/server/auth/adapter.ts。

请在执行报告中明确写出：当前实际使用的是哪一种 Adapter。

2. 增强 AdapterError 诊断日志（通用步骤）

无论是哪种 Adapter，都统一按下面步骤增强日志，保证我们能看到 DB 的真实报错。

文件：src/lib/auth.ts（或实际 NextAuth 配置文件）

2.1 增加 logger.error 对 AdapterError 的展开

在 NextAuth 配置对象中添加（或合并到现有 logger）：

import type { NextAuthConfig } from "next-auth";

export const authConfig: NextAuthConfig = {
  // ...现有配置（adapter, providers, trustHost 等）,
  logger: {
    error(error) {
      console.error("[NextAuth][Error][raw]", error);

      // 针对 AdapterError 展开 cause
      if ((error as any).type === "AdapterError") {
        const adapterError = error as any;
        console.error("[NextAuth][AdapterError][kind]", adapterError.kind);
        if (adapterError.cause) {
          console.error(
            "[NextAuth][AdapterError][cause]",
            adapterError.cause,
          );
          // 如果是 PG 错误，通常会有这些字段
          const c = adapterError.cause as any;
          if (c.code || c.detail || c.schema || c.table || c.constraint) {
            console.error("[NextAuth][AdapterError][pg-details]", {
              code: c.code,
              detail: c.detail,
              schema: c.schema,
              table: c.table,
              constraint: c.constraint,
            });
          }
        }
      }
    },
    // 如果已有 logger 配置，请 merge 而不是覆盖
  },
  debug: process.env.NODE_ENV !== "production",
};


要求：

不要删除已有 logger 的其他行为，如果有就合并。

在执行报告中贴出一段完整的 AdapterError 日志示例（包含 cause）。

这一步做完，你在 Vercel 日志里就能看到 具体是哪个表 / 哪个字段 / 哪条约束报错。

3. 按 Adapter 类型修复（Cursor 需根据实际情况选择分支）

重要： 下面是「按类型的修复路线」，Cursor 要根据第 1 步识别的 Adapter 类型，只执行对应分支，不要三种都动。

3.1 如果是 PrismaAdapter

找到 prisma/schema.prisma（可能在根目录或 apps/web 下）。

确认存在以下四个模型（名称可以有前缀，但结构要兼容）：

User

Account

Session

VerificationToken

参考 Auth.js 默认 schema（可以从官方 PrismaAdapter 示例拷贝），关键点：

User.id 类型为 String @id @default(cuid()) 或 String @id @default(uuid())

Account 上的联合主键 @@id([provider, providerAccountId])

所有字段与 @auth/prisma-adapter 的预期一致。

检查是否已经为这些模型跑过 migration：

查看 prisma/migrations 下是否有对应的表创建 SQL。

如果没有，生成一次 migration（prisma migrate dev 本地，最终在生产使用 prisma migrate deploy）。

确保 NextAuth 使用的是这些表，而不是你业务的 users 表。

如果你当前误把业务 users 表当成 NextAuth 的 User 表来用，很容易因为主键类型/唯一约束不匹配触发 AdapterError。

推荐做法：

保持一套独立的 User / Account / Session 表给 NextAuth；

业务的 users 表通过 user_id 或 auth_user_id 与 NextAuth User 关联。

如果日志里显示的 DB 错误是类似：

relation "User" does not exist → 说明表根本没建好 → 按上面 schema + migration 修复。

column ... does not exist / invalid input syntax for type integer → 说明 schema 不匹配 → 对照官方 schema 调整模型和 migrations。

3.2 如果是 SupabaseAdapter

确认 DATABASE_URL 指向的是你用作 NextAuth 存储的数据库，而不是 drivequiz 主库或 ai-service 库。

SupabaseAdapter 一般依赖 Supabase 自带的 auth schema，如果你使用的是自定义 PG 而不是托管 Supabase auth，需要确认：

是否执行了官方提供的 auth 相关 SQL 脚本，创建了 users / identities 等表。

查看 AdapterError 的 cause：

如果是 relation "users" does not exist → 缺 auth 表；

如果是 column ... does not exist → schema 不兼容；

按官方示例修复 schema 或改用 PrismaAdapter + 自建表更可控。

3.3 如果是自定义 Adapter

这里是最可能出问题的地方（跟你 drivequiz 的业务表结构耦合度高）。

以 drivequiz 主库里的 users 表结构为例（你已有文档）：

id 为 INTEGER 自增主键

email 为 VARCHAR(255) 非空唯一

还有一个 userid（VARCHAR(255) 唯一，用作业务唯一标识）

在这种情况下，如果你把 NextAuth 的 User.id 直接映射到 users.id（integer），但 Auth.js 默认期望 id 为 string（uuid/cuid），就极容易在 INSERT 时触发：

invalid input syntax for type integer

或某些约束冲突（unique/foreign key）

建议的修复策略：

在数据库中，把 NextAuth 的用户标识与业务主键彻底区分开：

继续保留 users.id 作为业务整型主键；

使用 users.userid（VARCHAR(255)，已唯一）作为 NextAuth User.id 的映射字段。

在自定义 Adapter 中调整实现（大致如下逻辑，Cursor 要按实际代码改）：

createUser(user)：

生成一个 authUserId（可以用 crypto.randomUUID()）；

插入到 users 表：

userid = authUserId

email = user.email

name = user.name 等

返回 { id: authUserId, email, name, image } 这一套给 NextAuth。

getUser(id) / getUserByEmail(email)：

按 userid 或 email 去查 users 表，

映射回 { id: row.userid, email: row.email, name: row.name, image: ... }。

linkAccount / getUserByAccount / createSession 等

建议使用 单独的 auth_accounts / auth_sessions 表 存 provider 和 session 信息，

这些表里的 userId 字段类型为 VARCHAR，存的就是 users.userid。

常见 AdapterError 场景 & 对应修复：

唯一约束冲突（cause 里有 duplicate key value violates unique constraint）：

说明 email 或 userid 冲突了。

在 createUser 中需要先 SELECT 看是否已有该 email 的用户，如果有则复用而不是重新插入。

类型错误（cause 里有 invalid input syntax for type integer）：

说明你把 string id 填到了 integer 字段上，或反之。

避免直接使用 id 整型作为 NextAuth 主键，统一改用 userid（string）。

要求：

Cursor 在修改自定义 Adapter 时，要严格参考 Auth.js Adapter 接口的定义，保证每个方法都返回 Auth.js 期待的结构。

修改后在执行报告里用小节说明：

现在 NextAuth 的 User.id 映射到哪个字段（例如 users.userid）；

哪些表专门用于存 accounts / sessions。

4. 清理无用代码 & 避免继续膨胀

在完成上述修复后，请 Cursor 做一次针对「认证相关」代码的瘦身：

在整个仓库搜索：

TODO: debug

临时日志 / console.log("[DEBUG

之前为 OAuth/Adapter 排查添加但现在已不再使用的辅助函数（在 v4 前后出现的）。

删除或合并以下类型的代码：

重复输出同样内容的日志；

只在 v1–v3 修复中临时使用、现在已被 v4/v5 逻辑取代的工具函数；

任何仍然试图从 Request Host 推导 base URL 的代码（所有 baseUrl 统一由 getAuthBaseUrl() 提供）。

保留的诊断能力仅限：

/api/auth/debug/google-redirect（用于查看 baseUrl 和 expectedRedirectUri）；

NextAuth logger 中的 AdapterError cause 展开。

请在执行报告中直接列一个「删除的无用代码清单」，注明文件 & 作用。

5. 本次任务的验收标准（必须写进新的「AdapterError 执行报告」）

从 Vercel 日志中粘一段完整的 [NextAuth][AdapterError][cause] 日志，

包含 code / detail / table / constraint 等信息。

并在报告中用自然语言解释：最终问题是「哪张表」的「什么约束/字段」出错。

说明采用的是哪种 Adapter 分支，以及对 schema / 逻辑做了什么具体修复，例如：

PrismaAdapter：补齐了 User/Account/Session 模型和 migration。

SupabaseAdapter：修正了 auth schema 或 DATABASE_URL。

自定义 Adapter：调整了 User.id 映射、处理了 email 冲突逻辑、增加专用 auth_accounts 表等。

再次实际测试三种登录（LINE / X / Google）：

都能从 provider 回调回来，

不再出现 AdapterError，

登录后能在 DB 中看到对应的 user + account 记录，

前端不再是「无法登录，因为此应用发送的请求无效」。

代码瘦身结果：

列出本次删除的临时代码/日志（文件 & 大致说明），

确认 env/auth 模块中没有重复逻辑、没有历史回退方案残留。