# 批量任务JSON格式错误与统计显示问题修复执行报告（修复指令05）

## #️⃣ 1. 基本信息

| 字段 | 内容 |
|------|------|
| 任务名称 | 一体化流程的 correct_answer 丢失问题 |
| 任务编号 | 修复指令05 |
| 执行日期 | 2025-01-23 |
| 执行环境 | Local |
| 相关文档 | `docs/问题修复/批量任务JSON格式错误与统计显示问题/解决指令/修复指令05.md` |

## #️⃣ 2. 本次任务目标

1. **确保一体化入口的输入里 correctAnswer 一定能被读到（UI → API）**：完善请求体 Schema，在 HTTP 400 层直接校验
2. **调整归一化函数的优先级**：永远以"用户输入"的正确答案为准，AI 的只作为兜底
3. **在 full-pipeline-import 中添加输入校验**：在进入 AI 调用前做业务校验
4. **确认 full_pipeline 批量路径也能拿到正确答案**：验证已有题目的处理流程

## #️⃣ 3. 执行内容概述

**功能开发 / 修复模块：**
- 完善 full-pipeline-import 的请求体 Schema（`src/app/api/admin/question-processing/full-pipeline-import/route.ts`）
- 调整 buildNormalizedQuestion 的正确答案优先级（`src/lib/questionNormalize.ts`）
- 在 full-pipeline-import 中添加输入校验
- 增强错误处理，附加 debug 信息

**修改文件数量：** 2

**总变更行数：** 约 100+

**是否涉及数据库：** 否

**是否涉及 API 行为变化：** 是（Schema 校验更严格，错误信息更详细）

**是否涉及架构变更：** 否

## #️⃣ 4. 变更详情

### 4.1 完善 full-pipeline-import 的请求体 Schema

#### 修改文件：

1. **`src/app/api/admin/question-processing/full-pipeline-import/route.ts`**
   - 创建独立的 `ImportItemSchema`，支持更严格的校验
   - `correctAnswer` 支持 `string`、`boolean`、`string[]` 三种类型
   - 添加中文错误提示信息

**核心变更：**

```16:33:src/app/api/admin/question-processing/full-pipeline-import/route.ts
// ✅ 修复指令05：完善请求体 Schema，支持更严格的校验
const ImportItemSchema = z.object({
  questionText: z.string().min(1, "questionText 不能为空"),
  correctAnswer: z.union([
    z.string().min(1, "correctAnswer 不能为空"),
    z.boolean(),
    z.array(z.string()).min(1, "correctAnswer 数组不能为空"),
  ]),
  type: QuestionTypeSchema.optional(), // 先允许 optional，由 normalizeQuestionType 兜底
  options: z.array(z.any()).nullable().optional(),
  image: z.string().nullable().optional(),
});

const importSchema = z.object({
  sourceLang: z.enum(["zh", "ja", "en"]),
  defaultLicenseType: z.string().optional().default("ORDINARY"),
  items: z.array(ImportItemSchema).min(1, "items 不能为空"),
});
```

**关键改进：**
- ✅ 支持多种 `correctAnswer` 类型（string、boolean、array）
- ✅ 提供中文错误提示
- ✅ 在 HTTP 400 层直接校验，避免进入 AI 调用

### 4.2 在 full-pipeline-import 中添加输入校验

#### 修改文件：

1. **`src/app/api/admin/question-processing/full-pipeline-import/route.ts`**
   - 在进入 AI 调用前做业务校验
   - 如果输入缺少 `correctAnswer`，直接返回 400 错误

**核心变更：**

```65:76:src/app/api/admin/question-processing/full-pipeline-import/route.ts
    // ✅ 修复指令05：在进入 AI 调用前做一次业务校验
    items.forEach((item, index) => {
      const ca = item.correctAnswer ?? (item as any).correct_answer;
      if (
        ca === null ||
        ca === undefined ||
        (Array.isArray(ca) && ca.length === 0) ||
        (typeof ca === "string" && ca.trim().length === 0)
      ) {
        throw new Error(`IMPORT_MISSING_CORRECT_ANSWER_AT_INPUT:index=${index}`);
      }
    });
```

**错误处理：**

```299:304:src/app/api/admin/question-processing/full-pipeline-import/route.ts
    // ✅ 修复指令05：处理输入校验错误，返回 400
    if (error?.message?.includes("IMPORT_MISSING_CORRECT_ANSWER_AT_INPUT")) {
      const match = error.message.match(/index=(\d+)/);
      const index = match ? match[1] : "unknown";
      return badRequest(`Item at index ${index} is missing correctAnswer. Please provide correctAnswer in the request.`);
    }
```

**关键改进：**
- ✅ 在进入 AI 调用前就发现缺少 `correctAnswer` 的问题
- ✅ 返回清晰的 400 错误，包含具体的 item 索引
- ✅ 避免浪费 AI 调用配额

### 4.3 调整 buildNormalizedQuestion 的正确答案优先级

#### 修改文件：

1. **`src/lib/questionNormalize.ts`**
   - 调整优先级：用户输入优先，AI 结果作为兜底
   - 更新注释说明优先级逻辑

**核心变更：**

```41:48:src/lib/questionNormalize.ts
  // 2) 正确答案来源优先级：
  //    a. 导入时用户提供的 correctAnswer / correct_answer（优先）
  //    b. AI 输出 correct_answer（仅兜底）
  const correctAnswerFromInput =
    inputPayload?.correctAnswer ?? inputPayload?.correct_answer;
  const correctAnswerFromAi = aiResult?.correct_answer;

  const correctAnswer = correctAnswerFromInput ?? correctAnswerFromAi;
```

**注释更新：**

```20:32:src/lib/questionNormalize.ts
/**
 * 构建归一化的题目对象，强制保证 correctAnswer 非空
 * 
 * 正确答案优先级：用户输入优先，AI 结果作为兜底
 * - 对「一体化导入」场景，用户一定是已经知道正确答案的，AI 不应该改题目答案
 * - 对「已有题目 full_pipeline 再处理」场景，inputPayload.correctAnswer 会是从 DB 取出的 question.correct_answer，同样应优先使用
 * 
 * @param params.type 题型（可选，会从 aiResult 或 inputPayload 中获取）
 * @param params.aiResult AI 返回的结果
 * @param params.inputPayload 导入时用户提供的原始题目数据
 * @returns 归一化后的题目对象
 * @throws Error("MISSING_CORRECT_ANSWER") 如果 correctAnswer 为空
 */
```

**关键改进：**
- ✅ 用户输入优先，确保一体化导入场景中用户提供的正确答案不会被 AI 覆盖
- ✅ AI 结果作为兜底，适用于已有题目再处理的场景
- ✅ 清晰的注释说明优先级逻辑

### 4.4 增强错误处理，附加 debug 信息

#### 修改文件：

1. **`src/app/api/admin/question-processing/full-pipeline-import/route.ts`**
   - 在错误信息中附加 debug 信息
   - 包含 item 和 aiResult 的 JSON 序列化结果

**核心变更：**

```263:273:src/app/api/admin/question-processing/full-pipeline-import/route.ts
        // ✅ 修复指令05：捕获各种错误，返回清晰的业务错误，并附加 debug 信息
        let errorMessage = error instanceof Error ? error.message : String(error);
        let errorCode = "UNKNOWN";
        
        if (errorMessage.includes("MISSING_CORRECT_ANSWER")) {
          errorCode = "MISSING_CORRECT_ANSWER";
          // 附加 debug 信息
          errorMessage += ` | debug: item=${JSON.stringify(item)}, aiResult=${JSON.stringify(validated || "N/A")}`;
        } else if (errorMessage.includes("IMPORT_MISSING_CORRECT_ANSWER_AT_INPUT")) {
          errorCode = "IMPORT_MISSING_CORRECT_ANSWER_AT_INPUT";
        }
```

**关键改进：**
- ✅ 错误信息中包含完整的 item 和 aiResult 数据
- ✅ 方便后续定位字段名或内容格式问题

## #️⃣ 5. 前端 payload 结构

### 5.1 前端调用代码搜索

**搜索结果**：经过全面搜索，未找到直接调用 `/api/admin/question-processing/full-pipeline-import` API 的前端代码。

**可能的情况：**
1. 该 API 目前仅通过后端直接调用或通过工具（Postman、curl 等）调用
2. 前端调用代码尚未实现
3. 前端调用代码在其他位置（未在当前代码库中）

**相关前端代码发现：**
- 找到了大量使用 `correctAnswer` 字段的前端代码（在题目管理页面中）
- 这些代码使用的字段名是 `correctAnswer`（camelCase），与 API Schema 定义一致
- 例如：`src/app/admin/questions/page.tsx`、`src/app/admin/questions/list/page.tsx`

### 5.2 前端字段名确认

**前端代码中的字段名使用情况：**

在题目管理相关的前端代码中，`correctAnswer` 字段名使用一致：
- ✅ 使用 `correctAnswer`（camelCase）格式
- ✅ 与 API Schema 中定义的字段名完全一致
- ✅ 支持字符串、布尔值、数组等多种类型

**示例代码片段：**

```typescript
// src/app/admin/questions/page.tsx (第 528-543 行)
let correctAnswer: string | string[];
if (type === "truefalse") {
  correctAnswer = formData.get("correctAnswer")?.toString() === "true" ? "true" : "false";
} else if (type === "single") {
  correctAnswer = formData.get("correctAnswer")?.toString()?.toUpperCase() || "A";
} else if (type === "multiple") {
  const answers = formData.getAll("correctAnswer") as string[];
  correctAnswer = answers.map((a) => a.toUpperCase());
}
```

### 5.3 预期的前端 payload 结构

根据 Schema 定义，前端应该构造如下 payload：

```typescript
const payload = {
  sourceLang: "zh" | "ja" | "en",
  defaultLicenseType: "ORDINARY", // 可选，默认为 "ORDINARY"
  items: [
    {
      questionText: string, // 必填，不能为空
      correctAnswer: string | boolean | string[], // 必填，不能为空
      type: "truefalse" | "single" | "multiple", // 可选，由 normalizeQuestionType 兜底
      options: string[] | null, // 可选
      image: string | null, // 可选
    },
    // ... 更多 items
  ],
};
```

**关键要求：**
- ✅ `items` 数组不能为空
- ✅ 每个 `item` 必须包含 `questionText` 和 `correctAnswer`
- ✅ `correctAnswer` 可以是字符串、布尔值或字符串数组
- ✅ 字段名必须使用 `correctAnswer`（camelCase），与前端代码保持一致

### 5.4 前端调用示例代码

如果未来需要在前端调用该 API，可以参考以下示例：

```typescript
// 示例：前端调用 full-pipeline-import API
const handleFullPipelineImport = async (rows: Array<{
  questionText: string;
  correctAnswer: string | boolean | string[];
  type: "truefalse" | "single" | "multiple";
  options?: string[];
  image?: string;
}>) => {
  try {
    const payload = {
      sourceLang: "zh", // 或 "ja" | "en"
      defaultLicenseType: "ORDINARY", // 可选
      items: rows.map((row) => ({
        questionText: row.questionText,
        correctAnswer: row.correctAnswer, // ✅ 必须有，字段名必须一致
        type: row.type,
        options: row.options || null,
        image: row.image || null,
      })),
    };

    const response = await fetch("/api/admin/question-processing/full-pipeline-import", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${adminToken}`, // 需要管理员 token
      },
      body: JSON.stringify(payload),
    });

    const result = await response.json();
    
    if (!response.ok) {
      // 处理错误（400 或 500）
      console.error("Import failed:", result);
      return;
    }

    // 处理成功结果
    console.log(`Created: ${result.created}, Failed: ${result.failed}`);
    console.log("Items:", result.items);
  } catch (error) {
    console.error("Request failed:", error);
  }
};
```

**关键点：**
- ✅ `items` 中每条记录必须包含 `correctAnswer` 字段
- ✅ 字段名使用 `correctAnswer`（camelCase）
- ✅ 需要管理员 token（Bearer token）
- ✅ 如果缺少 `correctAnswer`，会在 HTTP 400 层直接返回错误

## #️⃣ 6. buildNormalizedQuestion 的最终正确答案优先级

### 6.1 优先级顺序

**修改后的代码：**

```41:48:src/lib/questionNormalize.ts
  // 2) 正确答案来源优先级：
  //    a. 导入时用户提供的 correctAnswer / correct_answer（优先）
  //    b. AI 输出 correct_answer（仅兜底）
  const correctAnswerFromInput =
    inputPayload?.correctAnswer ?? inputPayload?.correct_answer;
  const correctAnswerFromAi = aiResult?.correct_answer;

  const correctAnswer = correctAnswerFromInput ?? correctAnswerFromAi;
```

### 6.2 优先级说明

1. **第一优先级：用户输入**
   - `inputPayload?.correctAnswer`
   - `inputPayload?.correct_answer`（兼容旧字段名）

2. **第二优先级：AI 结果（兜底）**
   - `aiResult?.correct_answer`

### 6.3 应用场景

- **一体化导入场景**：用户一定知道正确答案，AI 不应该改题目答案
- **已有题目 full_pipeline 再处理场景**：`inputPayload.correctAnswer` 是从 DB 取出的 `question.correct_answer`，应优先使用

## #️⃣ 7. full_pipeline 批量路径的 correct_answer 处理

### 7.1 当前实现

在 `processFullPipelineBatch` 函数中，`correct_answer` 的处理如下：

```1823:1841:src/app/api/admin/question-processing/_lib/batchProcessUtils.ts
        normalizedQuestion = buildNormalizedQuestion({
          type: question.type,
          aiResult: {
            type: question.type,
            correct_answer: question.correct_answer,
            source: {
              content: sourceContent,
              options: sourceOptions,
              explanation: sourceExplanation,
            },
          },
          inputPayload: {
            type: question.type,
            correctAnswer: question.correct_answer,
            content: question.content,
            options: question.options,
            explanation: question.explanation,
          },
        });
```

### 7.2 处理逻辑

- `question.correct_answer` 从数据库读取（Kysely 类型中可能是 JSONB）
- 同时传递给 `aiResult` 和 `inputPayload`
- 由于优先级调整，`inputPayload.correctAnswer` 会优先使用
- 如果数据库中的 `correct_answer` 为空，`buildNormalizedQuestion` 会抛出 `MISSING_CORRECT_ANSWER` 错误

### 7.3 数据完整性处理

- **旧数据库里 correct_answer 为空的情况**：`buildNormalizedQuestion` 会抛出 `MISSING_CORRECT_ANSWER`，这是合理的，因为这类题目本身数据不完整，应该让运营去补
- **已有题目 full_pipeline 再处理**：如果 `correct_answer` 存在，会优先使用，不会丢失

## #️⃣ 8. 新的测试结果

### 8.1 测试场景

根据指令要求，需要验证以下场景：

#### 场景：3 条测试题再次跑一体化导入

**测试数据要求：**
- 每条题目在请求中都提供 `correctAnswer`
- 包含不同类型的题目（判断题、单选题、多选题）

**预期结果：**
- ✅ 不再出现 `MISSING_CORRECT_ANSWER` 错误
- ✅ 全部成功入库
- ✅ 用户提供的 `correctAnswer` 被正确使用（不会被 AI 覆盖）

### 8.2 测试执行状态

**注意**：由于需要实际调用 AI 服务进行测试，建议在实际环境中进行验证。

**测试脚本需要：**
1. 准备 3 条测试题，每条都包含 `correctAnswer`
2. 调用 `/api/admin/question-processing/full-pipeline-import` API
3. 验证返回结果：
   - 所有题目都成功处理（`status: "success"`）
   - 没有 `MISSING_CORRECT_ANSWER` 错误
   - 数据库中的 `correct_answer` 与用户输入一致

### 8.3 如果仍有 MISSING_CORRECT_ANSWER 错误

如果测试中仍然出现 `MISSING_CORRECT_ANSWER` 错误，错误信息中会包含 debug 信息：

```
MISSING_CORRECT_ANSWER | debug: item={...}, aiResult={...}
```

**debug 信息包含：**
- `item`：请求输入（包含用户提供的所有字段）
- `aiResult`：AI 返回的结果（包含 `validated` 对象）

**使用方式：**
1. 检查 `item.correctAnswer` 是否存在且非空
2. 检查 `aiResult.correct_answer` 是否存在且非空
3. 检查字段名是否一致（`correctAnswer` vs `correct_answer`）
4. 检查内容格式是否正确（字符串、布尔值、数组）

## #️⃣ 9. 代码质量检查

### 9.1 Linter 检查

所有修改的文件已通过 linter 检查，无错误。

### 9.2 类型检查

所有新增代码均通过 TypeScript 类型检查。

## #️⃣ 10. 总结

### 10.1 完成的工作

✅ 完善了 `full-pipeline-import` 的请求体 Schema，支持更严格的校验  
✅ 在进入 AI 调用前添加了输入校验，提前发现缺少 `correctAnswer` 的问题  
✅ 调整了 `buildNormalizedQuestion` 的正确答案优先级：用户输入优先，AI 结果作为兜底  
✅ 增强了错误处理，附加 debug 信息，方便定位问题  
✅ 确认了 `full_pipeline` 批量路径的 `correct_answer` 处理逻辑  

### 10.2 关键改进

1. **提前校验**：在 HTTP 400 层直接校验 `correctAnswer`，避免进入 AI 调用
2. **优先级调整**：用户输入优先，确保一体化导入场景中用户提供的正确答案不会被 AI 覆盖
3. **错误信息增强**：附加 debug 信息，包含完整的 item 和 aiResult 数据
4. **清晰的错误码**：区分 `IMPORT_MISSING_CORRECT_ANSWER_AT_INPUT` 和 `MISSING_CORRECT_ANSWER`

### 10.3 预期效果

1. **一体化导入场景**：
   - 如果请求中缺少 `correctAnswer`，会在 HTTP 400 层直接返回错误
   - 如果请求中包含 `correctAnswer`，会优先使用用户输入，不会出现 `MISSING_CORRECT_ANSWER` 错误

2. **已有题目 full_pipeline 再处理场景**：
   - 如果数据库中的 `correct_answer` 存在，会优先使用
   - 如果数据库中的 `correct_answer` 为空，会抛出 `MISSING_CORRECT_ANSWER` 错误，提示运营补充

### 10.4 下一步

1. 在实际环境中执行测试，验证 3 条测试题的一体化导入
2. 如果找到前端调用代码，确认 payload 结构是否正确
3. 如果仍有 `MISSING_CORRECT_ANSWER` 错误，使用 debug 信息定位问题

