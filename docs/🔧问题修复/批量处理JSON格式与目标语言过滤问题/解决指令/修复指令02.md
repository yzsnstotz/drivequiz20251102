ğŸ§± ä»»åŠ¡æ€»è§ˆï¼ˆç»™ Cursorï¼‰

æœ¬ä»»åŠ¡å—ä»¥ä¸‹è§„èŒƒçº¦æŸï¼š

è·¯ç”±ç¦æ­¢æ‰¿è½½ä¸šåŠ¡é€»è¾‘ï¼Œæ‰€æœ‰æ ¸å¿ƒé€»è¾‘å¿…é¡»åœ¨å·¥å…·å‡½æ•°å±‚ï¼ˆ_lib/ã€src/lib/ï¼‰ã€‚

æ•°æ®åº“ç»“æ„ä»¥ã€ŠDriveQuiz æ•°æ®åº“ç»“æ„è¯´æ˜ã€‹ã€ŠAI-Service æ•°æ®åº“ç»“æ„è¯´æ˜ã€‹ä¸ºå”¯ä¸€çœŸç›¸æºã€‚

ä½ éœ€è¦å®Œæˆä»¥ä¸‹ 4 å¤§ä»»åŠ¡ï¼š

ä¿®æ­£ Kysely DB ç±»å‹å®šä¹‰

ä¿®æ­£ full_pipeline çš„å­—æ®µæ˜ å°„ä¸ processed_data ç»“æ„

ä¿®æ­£ saveQuestionToDb / SAVE_ALL_CHANGES_IN_TX å†™åº“é€»è¾‘

è¡¥å……æ—¥å¿—å’Œæœ€å°å›å½’æµ‹è¯•

ä¸‹é¢æ˜¯è¯¦ç»†æŒ‡ä»¤ã€‚

Task 1ï¼šä¿®æ­£ Kysely DB ç±»å‹å®šä¹‰ï¼ˆlicense_type_tag å¿…é¡»æ˜¯ JSONBï¼‰

ç›®æ ‡ï¼š è®© Kysely çŸ¥é“ questions.license_type_tag æ˜¯ JSONBï¼Œè€Œä¸æ˜¯ Postgres arrayï¼Œé¿å…æŠŠ {ALL,ORDINARY} å½“æˆ JSON å» castã€‚

1.1 å®šä½ DB ç±»å‹å®šä¹‰

åœ¨ web/drivequiz é¡¹ç›®ä¸­æœç´¢ï¼š

interface QuestionsTable


å…¸å‹ä½ç½®ä¹‹ä¸€ï¼ˆæŒ‰ç°æœ‰è°ƒç”¨æ ˆæ¨æ–­ï¼‰ï¼š

src/lib/db.ts æˆ–

src/lib/db/types.ts æˆ–ç±»ä¼¼ DB ç±»å‹å®šä¹‰æ–‡ä»¶ã€‚

åœ¨æ­¤ interface ä¸­ï¼Œæ‰¾åˆ° license_type_tagã€contentã€explanation ç­‰å­—æ®µã€‚

1.2 ä¿®æ”¹å­—æ®µç±»å‹ï¼ˆé‡ç‚¹ï¼‰

æŒ‰ç…§ DriveQuiz æ•°æ®åº“ç»“æ„è¯´æ˜ ä¸­ questions è¡¨çš„å®šä¹‰ï¼š

license_type_tag æ˜¯ JSONBï¼Œå†…å®¹ä¸ºæ•°ç»„ï¼Œä¾‹å¦‚ï¼š["GENERAL", "ORDINARY"]

content / explanation ä¹Ÿæ˜¯ JSONBï¼ˆå¤šè¯­è¨€å¯¹è±¡ï¼‰

è¯·å°† QuestionsTable ä¸­çš„å­—æ®µç±»å‹ç»Ÿä¸€æ”¹æˆï¼ˆç¤ºä¾‹ï¼‰ï¼š

import { JsonValue } from 'kysely';

export interface QuestionsTable {
  id: number;
  content_hash: string;
  type: string;
  options: JsonValue | null;        // JSONB
  correct_answer: JsonValue;        // JSONB
  image: string | null;
  version: string | null;
  created_at: Date | null;
  updated_at: Date | null;

  content: JsonValue;               // JSONBï¼Œå¤šè¯­è¨€é¢˜å¹²
  category: string | null;
  stage_tag: string | null;         // VARCHAR(20)
  topic_tags: string[] | null;      // text[]ï¼Œä¿æŒ array ç±»å‹
  explanation: JsonValue | null;    // JSONBï¼Œå¤šè¯­è¨€è§£æ

  // === å…³é”®ä¿®æ­£ç‚¹ ===
  // ä¹‹å‰å¦‚æœå†™æˆ string[] | nullï¼Œä¼šå¯¼è‡´ Kysely å½“æˆ Postgres array å¤„ç†
  // ä»è€Œç”Ÿæˆ '{ALL,ORDINARY}' è¿™æ ·çš„ array literalï¼ŒPostgres å† cast jsonb æ—¶æŠ¥é”™
  license_type_tag: JsonValue | null; // JSONBï¼Œå†…éƒ¨çº¦å®šä¸º string[]ï¼Œä¾‹å¦‚ ["ALL","ORDINARY"]
}


âš ï¸ æ³¨æ„ï¼šåªåœ¨ç±»å‹å±‚é¢ç”¨ JsonValueï¼Œä¸è¦æ‰‹åŠ¨ JSON.stringifyï¼Œäº¤ç»™ Kysely é©±åŠ¨å»åšã€‚

1.3 å…¨å±€æ›¿æ¢ä½¿ç”¨ç‚¹

å…¨å±€æœç´¢ license_type_tag çš„ä½¿ç”¨ï¼š

è¯»å–æ—¶ï¼š

å…è®¸æŒ‰å¦‚ä¸‹æ–¹å¼å–å€¼ï¼š

const licenseTypeTags = (row.license_type_tag as string[] | null) ?? [];


å†™å…¥æ—¶ï¼š

ä½¿ç”¨åŸç”Ÿ JS array å³å¯ï¼š

const tags: string[] = sanitized.tags?.license_type_tags ?? [];
update.license_type_tag = tags.length ? tags : null;


ä¸è¦å†ä½¿ç”¨ Postgres array ç±»å‹ï¼ˆå¦‚ string[] + array helperï¼‰å»æ„é€  license_type_tag çš„å€¼ã€‚

Task 2ï¼šä¿®æ­£ full_pipeline å­—æ®µæ˜ å°„ä¸ processed_data ç»“æ„

ç›®æ ‡ï¼š

æŠŠ AI è¾“å‡ºä¸­çš„ tags.stage_tags / tags.license_type_tags æ­£ç¡®æ˜ å°„åˆ° DB å­—æ®µ

é¿å… stage_tags / license_type_tags è¿™ç§å­—æ®µåç›´æ¥ç©¿é€åˆ° Save å±‚

2.1 å®šä½ full_pipeline æ ¸å¿ƒé€»è¾‘

æ ¹æ®å †æ ˆä¿¡æ¯ï¼Œç›¸å…³æ–‡ä»¶ï¼š

src/app/api/admin/question-processing/_lib/batchProcessUtils.ts

å…³é”®å‡½æ•°ï¼ˆå‘½åå¯èƒ½ç•¥æœ‰ä¸åŒï¼Œè¯·æ ¹æ®å…³é”®è¯å®šä½ï¼‰ï¼š

processFullPipelineBatch

processFullPipelineQuestion

sanitizeFullPipelineResponse / ç±»ä¼¼åå­—

æ„é€  processed_data çš„é€»è¾‘

è¯·å®Œæˆä»¥ä¸‹æ“ä½œï¼š

2.2 å®šä¹‰ä¸€ä¸ªæ˜ç¡®çš„â€œè½åº“ç»“æ„â€ç±»å‹

åœ¨ batchProcessUtils.ts é¡¶éƒ¨æ–°å¢ä¸€ä¸ªç±»å‹ï¼Œç”¨äºçº¦æŸ full_pipeline çš„ processed_dataï¼š

interface FullPipelineDbPayload {
  // å¤šè¯­è¨€é¢˜å¹²
  content?: Record<string, { content: string }>;
  // å¤šè¯­è¨€è§£æ
  explanation?: Record<string, { explanation: string }>;

  // === Tag æ˜ å°„åçš„ DB å­—æ®µ ===
  stage_tag?: string | null;          // å¯¹åº” questions.stage_tag
  topic_tags?: string[] | null;       // å¯¹åº” questions.topic_tags
  license_type_tag?: string[] | null; // å¯¹åº” questions.license_type_tag(JSONBï¼Œå†…éƒ¨æ•°ç»„)
}


æ³¨æ„ï¼šè¿™é‡Œæ•…æ„ç”¨ DB å­—æ®µåï¼Œä¸å†ç”¨ stage_tags / license_type_tagsã€‚

2.3 åœ¨ sanitize / buildProcessedData æ—¶å®Œæˆå­—æ®µæ˜ å°„

å¤„ç† AI å“åº”çš„åœ°æ–¹ï¼Œå¤§è‡´é€»è¾‘ï¼š

const { tags, source, translations } = sanitized; // sanitized æ˜¯ä½ å·²æœ‰çš„æ¸…æ´—ç»“æœ


è¯·æ–°å¢ä¸€ä¸ªä¸“é—¨çš„è½¬æ¢å‡½æ•°ï¼Œä¾‹å¦‚ï¼š

function buildFullPipelineDbPayload(
  sanitized: any,
  opts: {
    sourceLang: string;        // 'zh'
    targetLangs: string[];     // ['ja', ...]
  }
): FullPipelineDbPayload {
  const payload: FullPipelineDbPayload = {};

  // 1) content / explanation å¤šè¯­è¨€åˆå¹¶ï¼ˆä»…ç»“æ„ï¼Œä¸ç›´æ¥å†™åº“ï¼‰
  const content: Record<string, { content: string }> = {};
  const explanation: Record<string, { explanation: string }> = {};

  if (sanitized.source?.content) {
    content[opts.sourceLang] = { content: sanitized.source.content };
  }
  if (sanitized.source?.explanation) {
    explanation[opts.sourceLang] = { explanation: sanitized.source.explanation };
  }

  const translations = sanitized.translations ?? {};
  for (const [lang, value] of Object.entries<any>(translations)) {
    if (value?.content) {
      content[lang] = { content: value.content };
    }
    if (value?.explanation) {
      explanation[lang] = { explanation: value.explanation };
    }
  }

  if (Object.keys(content).length) {
    payload.content = content;
  }
  if (Object.keys(explanation).length) {
    payload.explanation = explanation;
  }

  // 2) Tags æ˜ å°„åˆ° DB å­—æ®µå
  const rawTags = sanitized.tags ?? {};

  // topic_tagsï¼šç›´æ¥é€ä¼  string[]ï¼Œæ³¨æ„ä¿è¯æ•°ç»„ç±»å‹
  if (Array.isArray(rawTags.topic_tags) && rawTags.topic_tags.length > 0) {
    payload.topic_tags = rawTags.topic_tags;
  }

  // license_type_tagï¼šAI è¾“å‡ºä¸º license_type_tagsï¼Œæ˜ å°„æˆ DB å­—æ®µåï¼ˆä¿æŒæ•°ç»„ï¼‰
  if (Array.isArray(rawTags.license_type_tags) && rawTags.license_type_tags.length > 0) {
    payload.license_type_tag = rawTags.license_type_tags;
  }

  // stage_tagï¼šå½“å‰ AI è¾“å‡ºä¸º stage_tags:string[]ï¼ŒDB ä¸ºå•å€¼
  // å…ˆé‡‡ç”¨ä¿å®ˆç­–ç•¥ï¼šå¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œåˆ™ç”¨è¯¥å…ƒç´ ï¼›å¤šäºä¸€ä¸ªåˆ™æš‚æ—¶ä¿ç•™åŸ DB å€¼ï¼ˆåœ¨ Save å±‚åˆå¹¶ï¼‰
  if (Array.isArray(rawTags.stage_tags) && rawTags.stage_tags.length === 1) {
    payload.stage_tag = rawTags.stage_tags[0];
  } else {
    // å¤šå€¼æˆ–æ— å€¼çš„æƒ…å†µç•™ç»™ Save å±‚ç»“åˆåŸå€¼å†³å®šï¼Œé¿å…ä¹±å†™
    payload.stage_tag = null;
  }

  return payload;
}

2.4 å°† payload å†™å…¥ question_processing_task_items.processed_data

åœ¨æ„å»º QuestionProcessingTaskItem çš„åœ°æ–¹ï¼ŒæŠŠ processed_data æ”¹æˆï¼š

const dbPayload = buildFullPipelineDbPayload(sanitized, {
  sourceLang,
  targetLangs,
});

await insertTaskItem({
  // ...
  processed_data: dbPayload,  // è¿™é‡Œå·²ç»æ˜¯ DB å±‚å¯æ¶ˆè´¹çš„ç»“æ„
  // ...
});


âš ï¸ å…³é”®ç‚¹ï¼š

processed_data é‡Œä¸å†å‡ºç° stage_tags / license_type_tags è¿™ç±»å­—æ®µåï¼Œåªä¿ç•™ DB å­—æ®µåã€‚

è¿™æ ·å¯ä»¥ä¿è¯ SAVE_ALL_CHANGES_IN_TX åªå¯¹æ¥ä¸€å¥—çº¦å®šå¥½çš„ç»“æ„ã€‚

Task 3ï¼šä¿®æ­£ saveQuestionToDb / SAVE_ALL_CHANGES_IN_TX å†™åº“é€»è¾‘

ç›®æ ‡ï¼š

æ ¹æ® processed_data çš„ç»“æ„å®‰å…¨æ›´æ–° questions è¡¨

æ­£ç¡®å¤„ç† JSONB / text[] ç±»å‹ï¼Œé¿å… invalid input syntax for type json

3.1 å®šä½ä¿å­˜å‡½æ•°

æ ¹æ®å †æ ˆä¿¡æ¯ï¼š

src/lib/questionDb.ts â†’ saveQuestionToDbï¼ˆline ~244ï¼‰

src/app/api/admin/question-processing/_lib/batchProcessUtils.ts â†’ processFullPipelineBatch

.../batch-process/route.ts â†’ processBatchAsync

è¯·åœ¨ batchProcessUtils.ts ä¸­æ‰¾åˆ°ç±»ä¼¼ SAVE_ALL_CHANGES_IN_TX çš„é€»è¾‘ï¼ˆå¯èƒ½æ˜¯æ³¨é‡Šæˆ– log æ ‡ç­¾ï¼‰ï¼Œè¯¥é€»è¾‘ä¸€èˆ¬ä¼šï¼š

ä» question_processing_task_items.processed_data å–å‡ºæ•°æ®

è°ƒç”¨ saveQuestionToDb å»æ›´æ–° questions è¡¨

3.2 è§„èŒƒ saveQuestionToDb çš„å…¥å‚

ä¸º saveQuestionToDb å®šä¹‰ä¸€ä¸ªæ˜ç¡®çš„å…¥å‚ç±»å‹ï¼Œä¾‹å¦‚ï¼š

interface QuestionUpdatePayload {
  id: number;
  // å¤šè¯­è¨€å†…å®¹å¢é‡
  content?: Record<string, { content: string }>;
  explanation?: Record<string, { explanation: string }>;

  // Tag æ›´æ–°
  stage_tag?: string | null;
  topic_tags?: string[] | null;
  license_type_tag?: string[] | null;
}

3.3 åœ¨ saveQuestionToDb å†…éƒ¨å®ç°å®‰å…¨åˆå¹¶ä¸å†™å…¥

ä¼ªä»£ç ç¤ºæ„ï¼š

export async function saveQuestionToDb(
  db: Kysely<Db>,
  payload: QuestionUpdatePayload
): Promise<void> {
  const existing = await db
    .selectFrom('questions')
    .selectAll()
    .where('id', '=', payload.id)
    .executeTakeFirstOrThrow();

  const update: Partial<QuestionsTable> = {};

  // 1) content å¤šè¯­è¨€åˆå¹¶ï¼ˆJSONBï¼‰
  if (payload.content) {
    const currentContent = (existing.content ?? {}) as Record<string, any>;
    for (const [lang, value] of Object.entries(payload.content)) {
      if (value?.content) {
        currentContent[lang] = value.content;
      }
    }
    update.content = currentContent;
  }

  // 2) explanation å¤šè¯­è¨€åˆå¹¶ï¼ˆJSONBï¼‰
  if (payload.explanation) {
    const currentExplanation = (existing.explanation ?? {}) as Record<string, any>;
    for (const [lang, value] of Object.entries(payload.explanation)) {
      if (value?.explanation) {
        currentExplanation[lang] = value.explanation;
      }
    }
    update.explanation = currentExplanation;
  }

  // 3) stage_tagï¼šåªåœ¨ payload.stage_tag æœ‰æ˜ç¡®å€¼æ—¶æ›´æ–°
  if (typeof payload.stage_tag === 'string') {
    update.stage_tag = payload.stage_tag;
  }

  // 4) topic_tagsï¼šç›´æ¥è¦†ç›–ï¼ˆç›®å‰æ²¡æœ‰å¤šæ¥æºåˆå¹¶éœ€æ±‚ï¼‰
  if (Array.isArray(payload.topic_tags)) {
    update.topic_tags = payload.topic_tags;
  }

  // 5) license_type_tag(JSONB)ï¼šå†…éƒ¨çº¦å®šä¸º string[]
  if (Array.isArray(payload.license_type_tag)) {
    update.license_type_tag = payload.license_type_tag;
  }

  if (Object.keys(update).length === 0) {
    // æ²¡æœ‰ä»»ä½•éœ€è¦æ›´æ–°çš„å­—æ®µï¼Œç›´æ¥è¿”å›
    return;
  }

  await db
    .updateTable('questions')
    .set(update)
    .where('id', '=', payload.id)
    .execute();
}


âœ… å…³é”®ç‚¹ï¼š

update.license_type_tag ç›´æ¥èµ‹å€¼ JS arrayï¼ˆç”±äºç±»å‹æ˜¯ JsonValueï¼ŒKysely ä¼šè‡ªåŠ¨åºåˆ—åŒ–ä¸º JSONBï¼‰

å†ä¹Ÿä¸ç”¨æ„é€  Postgres array literalï¼Œæ‰€ä»¥ä¸ä¼šå‡ºç° invalid input syntax for type jsonã€‚

3.4 åœ¨ SAVE_ALL_CHANGES_IN_TX ä¸­æ¶ˆè´¹ processed_data

åœ¨ processFullPipelineBatch å†…ï¼Œä» question_processing_task_items è¯»å‡º processed_data æ—¶ï¼ŒæŒ‰ä»¥ä¸‹æ–¹å¼è°ƒç”¨ï¼š

const processed = item.processed_data as FullPipelineDbPayload;

await saveQuestionToDb(db, {
  id: item.question_id,
  content: processed.content,
  explanation: processed.explanation,
  stage_tag: processed.stage_tag ?? undefined,
  topic_tags: processed.topic_tags ?? undefined,
  license_type_tag: processed.license_type_tag ?? undefined,
});


âš ï¸ ç¡®ä¿è¿™é‡Œä¸å†ä½¿ç”¨ processed.tags.stage_tags / processed.tags.license_type_tags è¿™ç±»å­—æ®µã€‚

Task 4ï¼šæ—¥å¿—ä¸æœ€å°å›å½’æµ‹è¯•
4.1 é”™è¯¯æ—¥å¿—å¢å¼º

åœ¨ SAVE_ALL_CHANGES_IN_TX çš„ catch åŒºå—ä¸­ï¼š

å¯¹ PROCESSING_FAILED / invalid input syntax for type json çš„æƒ…å†µï¼Œé¢å¤–è®°å½•ä»¥ä¸‹ä¿¡æ¯åˆ° question_processing_task_items.error_detailï¼š

dbUpdatePayload: å®é™…ä¼ ç»™ saveQuestionToDb çš„ payload

dbRowBefore: åŸé¢˜ç›® questions çš„å…³é”®å­—æ®µå¿«ç…§ï¼ˆid, stage_tag, topic_tags, license_type_tag, content, explanation çš„ç®€åŒ–é¢„è§ˆï¼‰

4.2 ä½¿ç”¨å½“å‰æŠ¥é”™ç¤ºä¾‹åšä¸€æ¬¡æ‰‹åŠ¨æµ‹è¯•ï¼ˆä¸ç”¨å†™ e2eï¼Œåªéœ€å•å…ƒ / é›†æˆï¼‰

ç”¨ä½ æä¾›çš„ sanitized ç¤ºä¾‹æ„é€ ä¸€æ¬¡ fake è°ƒç”¨ï¼Œç¡®ä¿å¯ä»¥è·‘é€šï¼š

æºè¯­è¨€ï¼šzh

ç›®æ ‡è¯­è¨€ï¼šja

sanitized.tags.license_type_tags = ["ALL","ORDINARY"]

sanitized.tags.stage_tags = ["FULL_LICENSE"]

sanitized.translations.ja / sanitized.source å¦‚ä½ ç¤ºä¾‹ä¸­æ‰€ç¤º

æµ‹è¯•ç‚¹ï¼š

buildFullPipelineDbPayload è¿”å›ï¼š

content å« zh å’Œ ja

explanation å« zh å’Œ ja

license_type_tag = ["ALL","ORDINARY"]

stage_tag = "FULL_LICENSE"ï¼ˆæˆ–æ ¹æ®ç­–ç•¥ä¿å®ˆä¸æ›´æ–°ï¼‰

è°ƒç”¨ saveQuestionToDb åï¼š

Postgres ä¸å†æŠ¥ invalid input syntax for type json

questions.license_type_tag ä¸­èƒ½çœ‹åˆ° JSONB æ•°ç»„ ["ALL","ORDINARY"]ï¼ˆç”¨ select license_type_tag::text éªŒè¯ï¼‰