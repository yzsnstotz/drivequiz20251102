🧭 任务目标

在 不改动数据库结构 / 业务逻辑 的前提下，修复 Vercel 构建时
TypeError: a.getExecutor is not a function（/api/auth/phone）的错误，
通过 简化占位符 Kysely 实现 + 在构建阶段绕过该路由的数据库调用，
确保 npm run build 在 Vercel 上可以顺利通过。

关联问题见《问题诊断报告：Vercel 构建时 Kysely 占位符 getExecutor 错误诊断》

🔧 修改范围

仅允许修改以下文件：

src/lib/db.ts

src/app/api/auth/phone/route.ts

禁止改动：

数据库 schema / SQL

其他 API 路由、页面组件

NextAuth 配置

STEP 1：彻底清理 Proxy 版占位符，实现“极简版 updateTable 占位符”

目标：撤回所有 Proxy 复杂实现，按诊断报告第 7.2 节的“简化方案”重写 updateTable 占位符。

1.1 打开并定位占位符实现

打开 src/lib/db.ts，找到占位符数据库实现部分（报告指出大致在 第 891–1009 行）。

定位包含 createPlaceholderDb 或类似命名的函数。

定位其中的 updateTable、set、where、execute、getExecutor 和任何 Proxy 相关代码。

1.2 移除所有 Proxy 相关实现

删除或重构掉以下类型的代码（来自提交 4123963 / ed0ec46 / a9102d1 / 487197b 中的改动）：

new Proxy(...) 包装 updateTable 返回对象

new Proxy(...) 包装 set() 返回对象

Proxy get trap 里对不存在属性返回“带 getExecutor 的对象”的逻辑

为 execute 做额外 .bind(target) 之类的显式绑定

原则：Proxy 全部删干净，只保留一个简单、可读的对象实现。

1.3 按诊断报告 7.2 节重写 updateTable 占位符

直接把报告中推荐的“简化方案”抄进来，并确保它是 createPlaceholderDb 中 updateTable 的实现：

// src/lib/db.ts 内，占位符 DB 的一部分
function createPlaceholderDb(): any {
  const sharedExecutor = {
    executeQuery: async () => ({ rows: [] }),
  };

  const placeholderDb: any = {
    // 只实现当前用到的 updateTable 链
    updateTable: () => {
      const updateBuilder: any = {
        set: (_updates: any) => {
          const setBuilder: any = {
            where: (..._args: any[]) => {
              return {
                execute: async () => [],
                getExecutor: () => sharedExecutor,
              };
            },
            execute: async () => [],
            getExecutor: () => sharedExecutor,
          };
          return setBuilder;
        },
        getExecutor: () => sharedExecutor,
      };
      return updateBuilder;
    },

    // 如果其他地方也会在构建时调用，可按同样模式补充：
    // selectFrom, insertInto 等
  };

  return placeholderDb;
}


要求：

updateTable().set().where().execute() 整条链上的任意对象，都必须有 getExecutor(): sharedExecutor。

execute() 返回 Promise（async () => []），以匹配 Kysely 的异步接口。

不允许再引入新的 Proxy / 动态魔法。

目的：如果构建阶段最终仍然走到了占位符 DB，至少不会再因为 getExecutor 缺失而崩。

STEP 2：在构建阶段绕过 /api/auth/phone 的 DB 操作

目标：即使占位符仍有潜在问题，也保证 构建阶段不会真正执行 Kysely 查询。

诊断报告确认，错误发生在 页面数据收集阶段，目标路由 /api/auth/phone，且具体 DB 调用为：

// src/app/api/auth/phone/route.ts
await db
  .updateTable("users")
  .set({
    phone: phone.trim(),
    updated_at: new Date(),
  })
  .where("id", "=", userId)
  .execute();

2.1 打开 /api/auth/phone 路由

打开：src/app/api/auth/phone/route.ts
确认当前导出的 HTTP 方法（通常是 POST，也可能有 GET）。

2.2 增加构建阶段检测常量

在文件顶部（导出 handler 之前）增加：

const IS_BUILD_TIME =
  typeof process.env.NEXT_PHASE !== "undefined" &&
  process.env.NEXT_PHASE === "phase-production-build";


说明：Next.js 在构建阶段会设置 NEXT_PHASE=phase-production-build，利用这个信号判断当前是否在构建。

2.3 在所有会触发 DB 调用的 handler 中加“构建短路”分支

假设你有一个 POST 处理函数，大致结构类似：

export async function POST(req: NextRequest) {
  // ... 解析 body / 校验
  await db.updateTable("users")...execute();
  return NextResponse.json({ ok: true });
}


请改成：

export async function POST(req: NextRequest) {
  if (IS_BUILD_TIME) {
    // 构建阶段不做任何 DB 读写，直接返回一个安全的占位响应
    return NextResponse.json(
      {
        ok: true,
        buildTimeStub: true,
      },
      { status: 200 }
    );
  }

  // === 以下为原有逻辑 ===
  // 解析 body / 校验
  // const { phone, userId } = ...
  // await db.updateTable("users")...execute();
  // return NextResponse.json({ ok: true });
}


如果还有 GET 或其他方法中也用到了 db，同样在最前面加上：

if (IS_BUILD_TIME) {
  return NextResponse.json(
    {
      ok: true,
      buildTimeStub: true,
    },
    { status: 200 }
  );
}


注意：

不要改动正常运行逻辑，只在构建阶段“短路”。

这一路由本身属于登录 / 认证用 API，构建阶段不会被真实用户调用，返回占位数据是安全的。

STEP 3：确认占位符 DB 的启用条件（防止构建时误用）

目标：确保在 Vercel 正式构建 & 运行环境 中，优先使用真实 Kysely 实例，而不是占位符。

在 src/lib/db.ts 中检查导出 db 的方式，通常会有类似：

const isPlaceholder = /* 某种条件，比如没有 DATABASE_URL */;
export const db = isPlaceholder ? createPlaceholderDb() : createRealDb();


请确保：

在 Vercel 生产环境，只要数据库连接串配置齐全（Supabase / Railway），就走 createRealDb()。

占位符只在 本地无 DB / 测试环境 才启用（比如 NODE_ENV === "test" 或明确 !process.env.DATABASE_URL）。

如果判断条件现在比较混乱，请整理为类似：

const hasDatabaseUrl = !!process.env.DATABASE_URL; // 或 SUPABASE_DB_URL 等

const shouldUsePlaceholder =
  process.env.NODE_ENV === "test" || !hasDatabaseUrl;

export const db = shouldUsePlaceholder
  ? createPlaceholderDb()
  : createRealDb();


这样在 Vercel 上，只要你在环境变量里配置了 DATABASE_URL，构建和运行都会使用真实 Kysely，不再依赖易碎的占位符。

STEP 4：本地验证与构建日志要求

让 Cursor 在本地按以下顺序执行，并在执行报告中写清楚每一步的结果：

代码检查

npm run lint


确保没有新的 TypeScript / ESLint 报错（已有的 hooks warning 可暂时忽略）。

本地构建

npm run build


要求在日志中确认：

再无 TypeError: a.getExecutor is not a function

再无 Failed to collect page data for /api/auth/phone 相关错误

模拟调用 /api/auth/phone

启动本地 dev 或使用 node 小脚本，在非构建环境下调用该路由一次，确认：

DB 逻辑仍正常执行（可以暂时在 handler 内加一行 console.log("[phone] DB update called") 来确认）

构建阶段是否走到“短路”分支，可以通过在 IS_BUILD_TIME 分支内加一次 console.log("[phone] build-time stub called")，然后在构建日志中观察是否出现（可选）。

STEP 5：给你（Leo）的结果汇报建议

请让 Cursor 在执行报告中至少说明三点，你就能一眼判断这次是否真的修好了：

db.ts 占位符代码对比

截图 / 粘贴重写后的 createPlaceholderDb().updateTable 实现（确认已完全采用简化方案、无 Proxy）。

route.ts 防护逻辑说明

明确指出在 /api/auth/phone 中新增了 IS_BUILD_TIME 检测，并在构建阶段绕过 DB 调用。

构建日志关键片段

npm run build 成功结束，且：

没有 a.getExecutor is not a function

没有 Failed to collect page data for /api/auth/phone