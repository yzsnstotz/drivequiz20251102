# Vercel 构建时 Kysely 占位符 getExecutor 错误诊断报告

**报告日期**: 2025-11-27  
**问题ID**: VERCEL-BUILD-20251127-001  
**问题等级**: High  
**当前状态**: 持续存在，未解决

---

## 📌 第一部分：问题概要（Summary）

| 字段 | 填写内容 |
|------|----------|
| **问题名称** | Vercel 构建时 Kysely 占位符对象 `getExecutor is not a function` 错误 |
| **问题等级** | High（阻塞生产部署） |
| **触发时间** | 2025-11-27 04:25:09（首次出现） |
| **触发环境** | Vercel 生产构建环境 |
| **相关模块** | Next.js 构建系统、Kysely 查询构建器、占位符数据库对象 |
| **影响范围** | `/api/auth/phone` 路由的页面数据收集阶段 |
| **当前状态** | 持续存在，经过 9 次修复尝试仍未解决 |

---

## 📌 第二部分：复现路径（Reproduce Steps）

### 触发场景

**构建环境**：
- Vercel 生产构建环境（Washington, D.C., USA (East) – iad1）
- Next.js 15.5.6
- Node.js 版本：未明确指定（Vercel 默认）

**触发步骤**：
1. 代码推送到 GitHub `register` 分支
2. Vercel 自动触发构建
3. Next.js 执行 `npm run build`
4. 编译和类型检查通过
5. 进入 "Collecting page data" 阶段
6. 尝试收集 `/api/auth/phone` 路由的页面数据
7. 执行路由处理函数中的数据库查询：`db.updateTable("users").set({...}).where("id", "=", userId).execute()`
8. **错误发生**：`TypeError: a.getExecutor is not a function`

**错误堆栈**：
```
TypeError: a.getExecutor is not a function
    at h (.next/server/chunks/2028.js:1:924)
    at e (.next/server/chunks/2684.js:1:5563)
    at <unknown> (.next/server/chunks/2684.js:1:6310)

> Build error occurred
[Error: Failed to collect page data for /api/auth/phone] {
  type: 'Error'
}
```

**关键代码路径**：
- `src/app/api/auth/phone/route.ts` 第 38-45 行
- `src/lib/db.ts` 第 924-996 行（`updateTable` 占位符实现）

---

## 📌 第三部分：错误信息（Error Messages）

### 主要错误

```
TypeError: a.getExecutor is not a function
    at h (.next/server/chunks/2028.js:1:924)
    at e (.next/server/chunks/2684.js:1:5563)
    at <unknown> (.next/server/chunks/2684.js:1:6310)
```

### 错误特征

1. **错误类型**：`TypeError`
2. **错误位置**：Kysely 内部代码（已编译的 chunk 文件）
3. **错误原因**：某个对象 `a` 没有 `getExecutor` 方法
4. **触发时机**：Next.js 构建时的页面数据收集阶段
5. **影响范围**：阻塞整个构建过程

### 错误上下文

- **构建阶段**：页面数据收集（Collecting page data）
- **目标路由**：`/api/auth/phone`
- **数据库操作**：`updateTable().set().where().execute()`
- **占位符状态**：构建时使用占位符数据库对象（`createPlaceholderDb()`）

---

## 📌 第四部分：问题分析（Analysis）

### 4.1 根本原因分析

**问题本质**：
- Next.js 在构建时会尝试收集所有路由的页面数据
- 对于 API 路由，Next.js 会执行路由处理函数来收集数据
- `/api/auth/phone` 路由中包含数据库查询操作
- 在构建时，数据库连接可能不可用，因此使用占位符对象
- Kysely 在执行查询时，内部会调用 `getExecutor()` 方法
- 占位符对象的某个中间对象缺少 `getExecutor` 方法

**技术细节**：
1. Kysely 的查询构建器使用链式调用：`updateTable().set().where().execute()`
2. 每个链式调用返回的对象都需要有 `getExecutor()` 方法
3. Kysely 内部在执行 `execute()` 时，会访问查询构建器的 `getExecutor()` 方法
4. 占位符对象需要完全模拟真实 Kysely 对象的行为

### 4.2 问题定位

**问题代码**：
```typescript
// src/app/api/auth/phone/route.ts
await db
  .updateTable("users")
  .set({
    phone: phone.trim(),
    updated_at: new Date(),
  })
  .where("id", "=", userId)
  .execute();
```

**占位符实现**：
```typescript
// src/lib/db.ts
updateTable: () => {
  // ... 占位符实现
}
```

**问题点**：
- Kysely 内部在某个地方访问了查询构建器链中的某个对象的 `getExecutor` 方法
- 该对象可能是：
  - `updateTable()` 返回的对象
  - `set()` 返回的对象
  - `where()` 返回的对象
  - 或者 Kysely 内部访问的其他属性

---

## 📌 第五部分：修改尝试汇总（Modification Attempts）

### 5.1 修改历史

自 2025-11-27 04:25:09 首次出现错误以来，共进行了 **9 次修复尝试**：

#### 尝试 1：初始修复 - 添加 getExecutor 方法
**提交**: `32ffcb9` - "修复占位符数据库对象：添加 getExecutor 方法以支持 Kysely 查询构建器"
**修改内容**：
- 在 `createQueryBuilder()` 中添加 `getExecutor` 方法
- 在 `insertInto().values()` 返回的对象中添加 `getExecutor` 方法

**结果**：❌ 失败，错误仍然存在

#### 尝试 2：重构 updateTable 实现
**提交**: `46883d6` - "改进占位符数据库对象：重构 updateTable 实现以确保正确的链式调用"
**修改内容**：
- 重构 `updateTable().set().where()` 链式调用
- 确保所有查询构建器对象都有 `getExecutor` 方法

**结果**：❌ 失败，错误仍然存在

#### 尝试 3：确保 where() 返回的对象有 getExecutor
**提交**: `ff84b9a` - "改进占位符数据库对象：确保 where() 返回的对象也有 getExecutor 方法"
**修改内容**：
- 在 `where()` 返回的对象上显式添加 `getExecutor` 方法

**结果**：❌ 失败，错误仍然存在

#### 尝试 4：确保 where() 返回完整的更新查询构建器
**提交**: `10ef079` - "改进占位符数据库对象：确保 where() 返回的对象本身就是一个完整的更新查询构建器"
**修改内容**：
- `where()` 返回的对象直接实现 `execute` 和 `getExecutor` 方法
- 不再依赖 `createQueryBuilder()`

**结果**：❌ 失败，错误仍然存在

#### 尝试 5：确保 updateTable() 返回的对象有 getExecutor
**提交**: `ae368a2` - "改进占位符数据库对象：确保 updateTable() 返回的对象本身也有 getExecutor 方法"
**修改内容**：
- 在 `updateTable()` 返回的对象上添加 `getExecutor` 方法
- 使用共享的 executor 对象

**结果**：❌ 失败，错误仍然存在

#### 尝试 6：使用 Proxy 拦截属性访问
**提交**: `4123963` - "改进占位符数据库对象：使用 Proxy 确保所有属性访问都返回有效的对象"
**修改内容**：
- 在 `createUpdateQueryBuilder()` 返回的对象上使用 Proxy
- 拦截所有属性访问，确保返回有效的对象

**结果**：❌ 失败，错误仍然存在

#### 尝试 7：在 set() 返回的对象上使用 Proxy
**提交**: `ed0ec46` - "改进占位符数据库对象：在 set() 返回的对象上使用 Proxy 确保所有属性访问都返回有效的对象"
**修改内容**：
- 在 `set()` 返回的对象上使用 Proxy 包装
- 拦截所有属性访问

**结果**：❌ 失败，错误仍然存在

#### 尝试 8：确保 execute() 方法正确绑定
**提交**: `a9102d1` - "改进占位符数据库对象：确保 execute() 方法正确绑定到目标对象"
**修改内容**：
- 确保 `execute()` 方法正确绑定到 `builder` 对象
- 在 Proxy 的 `get` 陷阱中，确保所有方法都绑定到 `target` 对象

**结果**：❌ 失败，错误仍然存在

#### 尝试 9：对于不存在的属性返回具有 getExecutor 的对象
**提交**: `487197b` - "改进占位符数据库对象：在 Proxy 的 get 陷阱中，对于不存在的属性返回具有 getExecutor 的对象"
**修改内容**：
- 在 Proxy 的 `get` 陷阱中，对于不存在的属性，返回一个具有 `getExecutor` 和 `execute` 方法的对象，而不是函数

**结果**：❌ 失败，错误仍然存在（截至报告生成时）

### 5.2 修改统计

| 指标 | 数值 |
|------|------|
| 总修改次数 | 9 次 |
| 修改文件数 | 1 个（`src/lib/db.ts`） |
| 修改行数 | 约 100+ 行 |
| 成功次数 | 0 次 |
| 失败次数 | 9 次 |
| 时间跨度 | 约 5 小时（04:25 - 09:10） |

---

## 📌 第六部分：修改必要性分析（Necessity Analysis）

### 6.1 修改的必要性

#### ✅ 必要的修改

1. **初始添加 getExecutor 方法**（尝试 1）
   - **必要性**：✅ 高
   - **理由**：Kysely 查询构建器确实需要 `getExecutor()` 方法
   - **结论**：此修改是必要的，但不够充分

2. **确保链式调用对象都有 getExecutor**（尝试 2-4）
   - **必要性**：✅ 高
   - **理由**：Kysely 的链式调用中，每个中间对象都可能被访问 `getExecutor`
   - **结论**：此修改方向正确，但实现可能不完整

#### ⚠️ 可能不必要的修改

3. **使用 Proxy 拦截属性访问**（尝试 6-9）
   - **必要性**：⚠️ 中等
   - **理由**：
     - Proxy 增加了代码复杂度
     - 可能影响性能（虽然构建时影响不大）
     - 如果 Kysely 内部访问的属性是已知的，直接实现可能更简单
   - **结论**：此修改可能是过度设计，但如果没有其他方法，也是合理的尝试

4. **方法绑定处理**（尝试 8）
   - **必要性**：⚠️ 低
   - **理由**：
     - 如果对象结构正确，方法绑定应该不是问题
     - 可能是对问题的误解
   - **结论**：此修改可能不必要

### 6.2 修改的有效性评估

| 修改尝试 | 必要性 | 有效性 | 复杂度 | 建议 |
|---------|--------|--------|--------|------|
| 尝试 1：初始添加 getExecutor | ✅ 高 | ⚠️ 部分有效 | 低 | 保留 |
| 尝试 2-4：链式调用对象 | ✅ 高 | ⚠️ 部分有效 | 中 | 保留核心逻辑 |
| 尝试 5：updateTable 对象 | ✅ 高 | ❌ 无效 | 低 | 保留 |
| 尝试 6-7：Proxy 拦截 | ⚠️ 中等 | ❌ 无效 | 高 | **考虑撤回** |
| 尝试 8：方法绑定 | ⚠️ 低 | ❌ 无效 | 中 | **考虑撤回** |
| 尝试 9：返回对象而非函数 | ⚠️ 中等 | ❌ 无效 | 高 | **考虑撤回** |

---

## 📌 第七部分：是否需要撤回修改的论证（Rollback Analysis）

### 7.1 撤回建议

#### 🔴 建议撤回的修改

1. **Proxy 相关的复杂实现**（尝试 6-9）
   - **理由**：
     - 增加了代码复杂度，但未解决问题
     - 可能掩盖了真正的问题
     - 维护成本高
   - **撤回范围**：
     - 移除 `createUpdateQueryBuilder()` 中的 Proxy 包装
     - 移除 `set()` 返回对象上的 Proxy 包装
     - 简化属性访问处理

2. **方法绑定处理**（尝试 8）
   - **理由**：
     - 如果对象结构正确，方法绑定应该不是问题
     - 可能是对问题的误解
   - **撤回范围**：
     - 移除 `builder.execute.bind(builder)` 的显式绑定
     - 移除 Proxy 中的方法绑定逻辑

#### ✅ 建议保留的修改

1. **getExecutor 方法的添加**（尝试 1）
   - **理由**：这是 Kysely 查询构建器的基本要求

2. **链式调用对象的 getExecutor**（尝试 2-5）
   - **理由**：确保链式调用中的每个对象都有 `getExecutor` 是正确方向

### 7.2 撤回后的建议实现

**简化方案**：
```typescript
updateTable: () => {
  const sharedExecutor = {
    executeQuery: async () => ({ rows: [] }),
  };
  
  const updateBuilder: any = {
    set: (updates: any) => {
      const setBuilder: any = {
        where: (...args: any[]) => {
          return {
            execute: async () => [],
            getExecutor: () => sharedExecutor,
          };
        },
        execute: async () => [],
        getExecutor: () => sharedExecutor,
      };
      return setBuilder;
    },
    getExecutor: () => sharedExecutor,
  };
  return updateBuilder;
},
```

**优势**：
- 代码简洁，易于理解
- 维护成本低
- 如果仍然失败，说明问题不在占位符实现上

### 7.3 替代方案

如果简化后仍然失败，考虑以下替代方案：

1. **跳过构建时的页面数据收集**
   - 在 `next.config.js` 中配置，跳过特定路由的数据收集
   - 使用 `export const dynamic = 'force-dynamic'` 可能不够

2. **使用 try-catch 包装数据库查询**
   - 在构建时捕获错误，返回空数据
   - 但这可能影响 Next.js 的静态优化

3. **重构路由，避免构建时执行数据库查询**
   - 将数据库查询移到运行时
   - 但这可能影响功能

4. **深入研究 Kysely 源码**
   - 查看 Kysely 内部如何访问 `getExecutor`
   - 找到真正的问题点

---

## 📌 第八部分：问题根源假设（Root Cause Hypothesis）

### 8.1 可能的问题根源

基于 9 次失败的修复尝试，我们提出以下假设：

#### 假设 1：Kysely 内部访问了未知属性
- **可能性**：🔴 高
- **证据**：所有已知对象的 `getExecutor` 都已添加，但错误仍然存在
- **验证方法**：深入研究 Kysely 源码，找到 `getExecutor` 的调用点

#### 假设 2：问题不在占位符实现，而在 Next.js 构建过程
- **可能性**：🟡 中等
- **证据**：错误发生在 Next.js 的页面数据收集阶段
- **验证方法**：尝试跳过该路由的数据收集，看是否解决问题

#### 假设 3：Kysely 版本兼容性问题
- **可能性**：🟡 中等
- **证据**：Kysely 的不同版本可能有不同的内部实现
- **验证方法**：检查 Kysely 版本，查看是否有已知问题

#### 假设 4：占位符对象的创建时机问题
- **可能性**：🟢 低
- **证据**：占位符对象在构建时创建，可能与 Kysely 的期望不符
- **验证方法**：尝试不同的占位符创建方式

### 8.2 验证优先级

1. **优先级 1**：深入研究 Kysely 源码，找到 `getExecutor` 的调用点
2. **优先级 2**：尝试跳过该路由的数据收集
3. **优先级 3**：检查 Kysely 版本兼容性
4. **优先级 4**：尝试不同的占位符创建方式

---

## 📌 第九部分：关键问题（Key Questions）

### 9.1 需要回答的问题

1. **Kysely 内部如何访问 getExecutor？**
   - 在哪个对象上调用？
   - 调用时机是什么？
   - 是否有其他必需的方法或属性？

2. **为什么所有已知对象的 getExecutor 都已添加，但错误仍然存在？**
   - 是否遗漏了某个对象？
   - 是否 Kysely 内部访问了其他属性？

3. **是否应该继续尝试修复占位符实现？**
   - 还是应该采用替代方案（跳过数据收集）？

4. **Proxy 的使用是否必要？**
   - 是否增加了不必要的复杂度？
   - 是否应该撤回？

### 9.2 需要额外信息

1. **Kysely 源码分析**
   - 找到 `getExecutor` 的调用点
   - 了解 Kysely 的内部实现

2. **Next.js 构建过程**
   - 了解页面数据收集的具体机制
   - 是否可以跳过特定路由的数据收集

3. **Vercel 构建环境**
   - 是否有特殊的构建配置
   - 是否有其他项目遇到类似问题

---

## 📌 第十部分：建议的下一步行动（Next Steps）

### 10.1 立即行动

1. **撤回无效的复杂修改**
   - 移除 Proxy 相关的复杂实现
   - 简化占位符对象实现
   - 保留核心的 `getExecutor` 方法

2. **深入研究 Kysely 源码**
   - 找到 `getExecutor` 的调用点
   - 了解 Kysely 的内部实现

3. **尝试替代方案**
   - 跳过该路由的数据收集
   - 或重构路由，避免构建时执行数据库查询

### 10.2 长期行动

1. **建立占位符对象的最佳实践**
   - 基于 Kysely 的官方文档或源码
   - 确保占位符对象完全模拟真实对象

2. **改进构建流程**
   - 避免在构建时执行数据库查询
   - 或提供更好的占位符机制

---

## 📌 第十一部分：附录（Attachments）

### 相关代码文件

1. `src/lib/db.ts` - 占位符数据库对象实现（第 891-1009 行）
2. `src/app/api/auth/phone/route.ts` - 触发错误的路由（第 38-45 行）

### 相关提交

1. `32ffcb9` - 修复占位符数据库对象：添加 getExecutor 方法以支持 Kysely 查询构建器
2. `46883d6` - 改进占位符数据库对象：重构 updateTable 实现以确保正确的链式调用
3. `ff84b9a` - 改进占位符数据库对象：确保 where() 返回的对象也有 getExecutor 方法
4. `10ef079` - 改进占位符数据库对象：确保 where() 返回的对象本身就是一个完整的更新查询构建器
5. `ae368a2` - 改进占位符数据库对象：确保 updateTable() 返回的对象本身也有 getExecutor 方法
6. `4123963` - 改进占位符数据库对象：使用 Proxy 确保所有属性访问都返回有效的对象
7. `ed0ec46` - 改进占位符数据库对象：在 set() 返回的对象上使用 Proxy 确保所有属性访问都返回有效的对象
8. `a9102d1` - 改进占位符数据库对象：确保 execute() 方法正确绑定到目标对象
9. `487197b` - 改进占位符数据库对象：在 Proxy 的 get 陷阱中，对于不存在的属性返回具有 getExecutor 的对象

### 相关文档

- Kysely 官方文档：https://kysely.dev/
- Next.js 构建文档：https://nextjs.org/docs/app/building-your-application/deploying

---

**报告生成时间**: 2025-11-27 09:10:06  
**报告生成工具**: Cursor AI Assistant  
**问题状态**: 🔴 未解决，需要进一步调查

