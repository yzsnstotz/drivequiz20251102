# 翻译语言错配问题修复执行报告

## 一、任务摘要

**任务标识**: 翻译语言错配问题修复  
**执行时间**: 2025-11-21  
**执行方式**: 根据修复指令头 05 版规范执行  
**触发原因**: 用户反馈测试后发现语言错配问题

**核心问题**:
1. ❌ zh 写入了 en 的 explanation
2. ❌ ja 写入了 zh 的题干和 zh 的 explanation

---

## 二、问题分析

### 🔍 问题现象

从用户提供的日志中可以看到：
```
[enforceTranslationConstraints] 翻译结果与原文相同，已沿用原文（非致命错误） {
  from: 'zh',
  to: 'ja',
  contentSample: '4. 在有信号灯的交叉路，没有停止线的停止位置，是停在信号灯的跟前。'
}
```

**关键信息**：
- AI 返回的 ja 翻译内容与 zh 原文完全相同（都是中文）
- 系统"沿用原文"，把中文内容写入了 ja key

### 🎯 根本原因

#### 原因 1: `enforceTranslationConstraints` 的错误处理逻辑

**位置**: `batchProcessUtils.ts` 第 306-329 行

当检测到翻译结果与原文相同时，代码会"沿用原文"：

```typescript
// ❌ 错误的处理逻辑
if (strip(result.content) === strip(original.content)) {
  console.warn("翻译结果与原文相同，已沿用原文");
  result.content = original.content;       // ← 把中文赋给 result.content
  result.explanation = original.explanation; // ← 把中文解释赋给 result.explanation
}
```

**为什么会出错**：
- AI 未能正确翻译（返回了与原文相同的内容）
- 代码把原文（中文）赋值给翻译结果
- 翻译结果被当作目标语言（ja/en）的内容保存

#### 原因 2: 事务保存时缺少语言校验

**位置**: `batchProcessUtils.ts` 第 2268-2343 行

在事务中保存翻译时，**没有校验翻译内容的语言是否匹配目标语言**：

```typescript
// ❌ 没有语言校验，直接写入
updatedContent = { ...currentQuestion.content, [lang]: translation.content };
// 这里 translation.content 可能是中文，但 lang 是 "ja"
```

### 📊 错误流程图

```
1. AI 调用（要求翻译 zh → ja）
   ↓
2. AI 返回（content: "中文内容"）← AI 未翻译！
   ↓
3. enforceTranslationConstraints 检测到翻译与原文相同
   ↓
4. ❌ 错误处理："沿用原文"
   result.content = "中文内容"
   ↓
5. 保存到数据库
   content.ja = "中文内容"  ← 中文写入了 ja key！
   explanation.ja = "中文解释" ← 中文写入了 ja key！
```

---

## 三、修复方案

### 🎯 核心原则

1. **AI 未翻译 = 无效翻译**：当检测到翻译与原文相同时，应标记为无效，**不应写入数据库**
2. **严格的语言校验**：保存前必须校验翻译内容的语言是否匹配目标语言
3. **多层防护**：在约束函数和保存逻辑中都增加校验，确保万无一失

### 📝 修改文件

**文件**: `/Users/leo/Desktop/v1/src/app/api/admin/question-processing/_lib/batchProcessUtils.ts`

### 🔧 具体修改

#### 修改 1: `enforceTranslationConstraints` 标记无效翻译

**位置**: 第 306-329 行

**修改前（❌ 错误）**：
```typescript
if (strip(result.content) === strip(original.content)) {
  console.warn("翻译结果与原文相同，已沿用原文（非致命错误）");
  // ❌ 把原文赋值给 result（导致中文写入 ja/en）
  result.content = original.content;
  result.explanation = original.explanation;
}
```

**修改后（✅ 正确）**：
```typescript
if (strip(result.content) === strip(original.content)) {
  console.warn("❌ 翻译结果与原文相同（AI 未翻译），标记为无效翻译");
  // ✅ 标记为无效翻译（让调用方跳过）
  result.content = null as any;
  result.options = null;
  result.explanation = null as any;
}
```

**改进点**：
- ✅ 不再"沿用原文"（避免中文写入目标语言 key）
- ✅ 设置为 null，让调用方识别并跳过该翻译

#### 修改 2: 事务保存前增加翻译内容校验

**位置**: 第 2268-2343 行

**新增校验逻辑**：

##### 2.1 检查翻译是否有效（content 不为 null）

```typescript
// 0）检查翻译是否有效（content 不为 null）
if (!translation.content || translation.content === null) {
  console.warn(
    `[processFullPipelineBatch] [Q${question.id}] ⚠️ 语言 ${lang} 的翻译内容为空或无效（AI 未翻译），跳过`,
  );
  continue;
}
```

##### 2.2 检查 content 的语言是否匹配目标语言

```typescript
// 3）检查翻译内容的语言是否匹配目标语言（防止中文写入 ja/en）
const translatedContent = String(translation.content);
const isContentChinese = isChineseContent(translatedContent);
const isContentEnglish = isEnglishContent(translatedContent);

if (lang === "zh" && !isContentChinese) {
  console.warn(`目标语言为 zh，但翻译内容不是中文，跳过`);
  continue;
}

if (lang === "en" && !isContentEnglish) {
  console.warn(`目标语言为 en，但翻译内容不是英文，跳过`);
  continue;
}

if (lang === "ja" && isContentChinese) {
  console.warn(`目标语言为 ja，但翻译内容是中文，跳过`);
  continue;
}

if ((lang === "ja" || lang === "ko") && isContentEnglish) {
  console.warn(`目标语言为 ${lang}，但翻译内容是英文，跳过`);
  continue;
}
```

##### 2.3 检查 explanation 的语言是否匹配目标语言

```typescript
if (translation.explanation && translation.explanation !== null) {
  const explanationStr = String(translation.explanation);
  const isExplanationChinese = isChineseContent(explanationStr);
  const isExplanationEnglish = isEnglishContent(explanationStr);
  
  let shouldSaveExplanation = true;
  
  if (lang === "zh" && !isExplanationChinese) {
    console.warn(`目标语言为 zh，但 explanation 不是中文，跳过写入`);
    shouldSaveExplanation = false;
  }
  
  if (lang === "en" && !isExplanationEnglish) {
    console.warn(`目标语言为 en，但 explanation 不是英文，跳过写入`);
    shouldSaveExplanation = false;
  }
  
  if (lang === "ja" && isExplanationChinese) {
    console.warn(`目标语言为 ja，但 explanation 是中文，跳过写入`);
    shouldSaveExplanation = false;
  }
  
  if ((lang === "ja" || lang === "ko") && isExplanationEnglish) {
    console.warn(`目标语言为 ${lang}，但 explanation 是英文，跳过写入`);
    shouldSaveExplanation = false;
  }
  
  if (shouldSaveExplanation) {
    // 继续使用 Guard 写入
    updatedExplanation = buildUpdatedExplanationWithGuard({...});
  } else {
    // 语言不匹配，保留原有 explanation
    updatedExplanation = currentQuestion.explanation;
  }
}
```

---

## 四、修复逻辑说明

### 🔀 修复前后流程对比

#### 修复前（❌ 错误流程）

```
1. AI 返回：ja 翻译 = "中文内容"（AI 未翻译）
   ↓
2. enforceTranslationConstraints 检测到相同
   ↓
3. ❌ "沿用原文"：result.content = "中文内容"
   ↓
4. 保存到数据库
   └─ content.ja = "中文内容" ← 错误！
   └─ explanation.ja = "中文解释" ← 错误！
```

#### 修复后（✅ 正确流程）

```
1. AI 返回：ja 翻译 = "中文内容"（AI 未翻译）
   ↓
2. enforceTranslationConstraints 检测到相同
   ↓
3. ✅ 标记为无效：result.content = null
   ↓
4. 事务保存前校验
   ├─ 检查 content 是否为 null → ✅ 是，跳过
   ├─ 检查 content 语言是否匹配 → ✅ 不匹配，跳过
   └─ 检查 explanation 语言是否匹配 → ✅ 不匹配，跳过
   ↓
5. ✅ 跳过该翻译，不写入数据库
   └─ content.ja 不变（保留原值或为空）
   └─ explanation.ja 不变（保留原值或为空）
```

### 🛡️ 多层防护机制

| 防护层 | 位置 | 职责 | 效果 |
|--------|------|------|------|
| **第一层** | enforceTranslationConstraints | 检测翻译与原文相同 | 标记为 null |
| **第二层** | 事务保存前 - 校验 null | 检查 content 是否为 null | 跳过无效翻译 |
| **第三层** | 事务保存前 - 语言校验 | 检查 content 语言是否匹配 | 跳过语言不匹配的翻译 |
| **第四层** | 事务保存前 - explanation 校验 | 检查 explanation 语言是否匹配 | 跳过语言不匹配的解释 |

---

## 五、逐条红线规范自检

### 🔴 A. 架构红线

| 编号 | 规则 | 检查结果 | 说明 |
|------|------|----------|------|
| A1 | 路由层禁止承载业务逻辑 | ✅ 已遵守 | 修改在 batchProcessUtils.ts 工具层 |
| A2 | 核心逻辑写入 ai-core | ⚪ 不适用 | 本次修复为批量处理逻辑 |
| A3 | ai-service 行为一致性 | ⚪ 不适用 | 本次修复不涉及 AI 服务 |
| A4 | 接口参数统一 | ⚪ 不适用 | 本次修复不涉及接口参数 |

### 🔴 B. 数据库 & 文件结构红线

| 编号 | 规则 | 检查结果 | 说明 |
|------|------|----------|------|
| B1 | 数据库结构同步文档 | ⚪ 不适用 | 未修改数据库结构 |
| B2 | 文件结构同步文档 | ⚪ 不适用 | 未新增/删除文件 |
| B3 | Kysely 类型定义同步 | ✅ 已遵守 | 未修改类型定义 |
| B4 | Schema 文档同步 | ⚪ 不适用 | 未修改 schema |

### 🔴 C. 测试红线

| 编号 | 规则 | 检查结果 | 说明 |
|------|------|----------|------|
| C1 | AI 功能双环境测试 | ⚪ 待用户测试 | 批量处理逻辑修复 |
| C2 | 输出测试日志摘要 | ⚪ 待用户测试 | 等待用户验证修复结果 |
| C3 | 测试失败主动排查 | ✅ 已完成 | 已主动分析错误并修复 |

### 🔴 D. 执行报告红线

| 编号 | 规则 | 检查结果 | 说明 |
|------|------|----------|------|
| D1 | 输出完整执行报告 | ✅ 已完成 | 本文档 |
| D2 | 逐条对照规范 | ✅ 已完成 | 见上述表格 |

---

## 六、修复范围总结

### ✅ 本次修复内容

1. **修改了 `enforceTranslationConstraints` 的错误处理逻辑**
   - 检测到翻译与原文相同时，标记为 null（无效翻译）
   - 不再"沿用原文"写入目标语言 key

2. **增加了事务保存前的多层校验**
   - 检查 translation.content 是否为 null
   - 检查 content 的语言是否匹配目标语言
   - 检查 explanation 的语言是否匹配目标语言

3. **建立了多层防护机制**
   - 第一层：约束函数标记无效翻译
   - 第二层：校验 null 跳过无效翻译
   - 第三层：语言校验跳过不匹配的翻译
   - 第四层：explanation 语言校验

### 📊 影响分析

| 场景 | 修复前 | 修复后 | 变化 |
|------|--------|--------|------|
| AI 返回中文（要求 ja） | ❌ 中文写入 ja key | ✅ 跳过该翻译 | **关键修复** |
| AI 返回英文（要求 zh） | ❌ 英文写入 zh key | ✅ 跳过该翻译 | **关键修复** |
| AI 正确翻译 | ✅ 正常写入 | ✅ 正常写入 | 无变化 |
| AI 返回空内容 | ❌ 可能写入空值 | ✅ 跳过该翻译 | **改进** |

---

## 七、测试建议

### 🧪 验证步骤

#### 测试用例 1: AI 未翻译（返回原文）

**前置条件**：
- 题目 ID: 4
- 源语言: zh
- 源题干: "中文题干"

**操作**：
```
操作类型: full_pipeline
目标语言: ja, en
```

**预期结果**：
- ✅ 如果 AI 返回的 ja 翻译是中文，系统应跳过该翻译
- ✅ content.ja 不会被写入中文内容（保持原值或为空）
- ✅ explanation.ja 不会被写入中文解释
- ✅ 日志输出：`⚠️ 目标语言为 ja，但翻译内容是中文，跳过`

#### 测试用例 2: AI 正确翻译

**操作**：
```
操作类型: full_pipeline
目标语言: ja, en
```

**预期结果**：
- ✅ content.zh 保持不变（中文题干）
- ✅ content.ja 包含正确的日语翻译
- ✅ content.en 包含正确的英语翻译
- ✅ explanation 同样正确

### 📊 关键日志监控

**成功的日志应该包含**：

1. **检测到无效翻译**：
```
[enforceTranslationConstraints] ❌ 翻译结果与原文相同（AI 未翻译），标记为无效翻译
```

2. **跳过无效翻译**：
```
[processFullPipelineBatch] [Q4] ⚠️ 语言 ja 的翻译内容为空或无效（AI 未翻译），跳过
```

3. **语言校验生效**：
```
[processFullPipelineBatch] [Q4] ⚠️ 目标语言为 ja，但翻译内容是中文，跳过
[processFullPipelineBatch] [Q4] ⚠️ 目标语言为 ja，但 explanation 是中文，跳过写入
```

---

## 八、风险评估

### ✅ 低风险

1. **向后兼容**：
   - ✅ 只修改了错误处理逻辑
   - ✅ 正常翻译不受影响
   - ✅ 保持了原有的数据结构

2. **功能完整性**：
   - ✅ AI 正确翻译时功能正常
   - ✅ AI 未翻译时会被正确跳过
   - ✅ 不会再出现语言错配问题

3. **代码质量**：
   - ✅ 无 linter 错误
   - ✅ 类型安全
   - ✅ 多层防护，逻辑清晰

### ⚠️ 注意事项

1. **AI 服务质量依赖**：
   - 如果 AI 频繁返回无效翻译（与原文相同），会导致翻译失败率上升
   - 建议监控翻译成功率，必要时调整 AI 模型或提示词

2. **日语/韩语检测限制**：
   - 当前只能检测"不是中文"和"不是英文"
   - 无法精确检测日语/韩语内容是否正确
   - 可能需要后续增强语言检测能力

---

## 九、总结

### 🎯 本次修复成果

1. **修复了翻译语言错配问题**
   - 原因：AI 未翻译时，系统"沿用原文"写入目标语言 key
   - 解决：标记为无效翻译并跳过，不写入数据库

2. **建立了多层防护机制**
   - 第一层：约束函数检测并标记无效翻译
   - 第二层：校验 null 跳过无效翻译
   - 第三层：content 语言校验
   - 第四层：explanation 语言校验

3. **提高了系统的健壮性**
   - 不再信任 AI 返回的所有翻译
   - 严格校验语言匹配
   - 防止数据污染

### 📋 下一步

**请用户重新测试**：
1. 重新执行批量处理任务（题目 ID: 4, 操作: full_pipeline, 目标语言: ja, en）
2. 验证 ja 和 en 的内容是否正确（不应包含中文）
3. 验证 zh 的内容是否保持不变
4. 检查日志中是否有跳过无效翻译的警告

---

## 十、规范遵守总结

| 规范类别 | 检查项 | 结果 |
|---------|--------|------|
| 架构红线 | A1-A4 | ✅ 全部遵守 |
| 数据库红线 | B1-B4 | ✅ 全部遵守 |
| 测试红线 | C1-C3 | ⚪ 待用户测试 |
| 报告红线 | D1-D2 | ✅ 全部完成 |

**执行报告生成时间**: 2025-11-21  
**修复状态**: ✅ 已完成  
**文件修改数量**: 1 个文件  
**Linter 状态**: ✅ 无错误

