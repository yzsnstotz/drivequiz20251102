# 指令0002实施报告

**指令版本：0002**  
**实施日期：2025-11-17**

## 一、任务概述

本次修复主要解决以下问题：
1. 确保心跳接口对 local/render 两端点检查稳定（使用新的超时 & 错误处理逻辑）
2. 修复 aiStatsClient 只用 render 端点的问题，改为按 provider 选择端点
3. 增加 DB provider → 前端 provider 的映射层（如 openai → render）
4. 优化 /api/ai/ask 410 返回信息

## 二、已完成的任务

### ✅ 任务 1：提取 resolveAiEndpoint 到公共 util

**新建文件**：`src/lib/aiEndpoint.ts`

**功能**：
- 提取 `resolveAiEndpoint` 函数到公共工具文件
- 定义 `AiProviderKey` 类型
- 统一端点解析逻辑，支持 `local` 和 `render` 两个 provider

**关键代码**：
```typescript
export type AiProviderKey = "local" | "render";

export function resolveAiEndpoint(provider: AiProviderKey): { url: string; token: string } {
  const endpoints = {
    local: {
      url: process.env.NEXT_PUBLIC_LOCAL_AI_SERVICE_URL,
      token: process.env.NEXT_PUBLIC_LOCAL_AI_SERVICE_TOKEN,
    },
    render: {
      url: process.env.NEXT_PUBLIC_RENDER_AI_SERVICE_URL,
      token: process.env.NEXT_PUBLIC_RENDER_AI_SERVICE_TOKEN,
    },
  } as const;
  // ... 验证和错误处理
}
```

**修改文件**：
- `src/lib/aiClient.front.ts` - 改为从 `./aiEndpoint` 引入 `resolveAiEndpoint`
- 移除重复的 `resolveAiEndpoint` 函数定义

### ✅ 任务 2：修复 aiStatsClient.ts 按 provider 选择端点

**文件**：`src/lib/aiStatsClient.ts`

**主要变更**：
1. 引入 `resolveAiEndpoint` 和 `AiProviderKey` 类型
2. 修改 `getAiExpectedTime` 函数，使用公共的 `resolveAiEndpoint` 函数
3. 改进错误处理，区分环境变量未配置和其他错误

**修改前**：
```typescript
const aiServiceUrl = provider === "local" 
  ? process.env.NEXT_PUBLIC_LOCAL_AI_SERVICE_URL
  : process.env.NEXT_PUBLIC_RENDER_AI_SERVICE_URL;
```

**修改后**：
```typescript
const { url, token } = resolveAiEndpoint(provider);
```

**验证**：
- ✅ `getAiExpectedTime("local", ...)` → 使用 `NEXT_PUBLIC_LOCAL_AI_SERVICE_URL`
- ✅ `getAiExpectedTime("render", ...)` → 使用 `NEXT_PUBLIC_RENDER_AI_SERVICE_URL`

### ✅ 任务 3：增加 DB provider → 前端 provider 的映射层

**新建文件**：`src/lib/aiProviderMapping.ts`

**功能**：
- 定义 `mapDbProviderToClientProvider` 函数
- 将数据库中的 provider 值（如 `"openai"`, `"openrouter"`, `"gemini"` 等）映射到前端使用的 provider（`"local"` | `"render"`）

**映射规则**：
- `"local"` → `"local"`
- `"render"` → `"render"`
- `"openai"`, `"openrouter"`, `"gemini"`, `"claude"`, `"strategy"` 等 → `"render"`
- 未知值 → `"render"`（默认兜底）

**修改文件**：
- `src/lib/aiProviderConfig.front.ts` - 使用 `mapDbProviderToClientProvider` 函数
- 移除硬编码的映射逻辑

**验证**：
- ✅ DB 中 `provider = "openai"` → 映射为 `"render"`
- ✅ DB 中 `provider = "openrouter"` → 映射为 `"render"`
- ✅ DB 中 `provider = "local"` → 映射为 `"local"`
- ✅ 不会再抛出 "endpoint not configured for provider: openai" 错误

### ✅ 任务 4：优化 /api/ai/ask 的 410 返回内容

**文件**：`src/app/api/ai/ask/route.ts`

**主要变更**：
1. 添加控制台警告日志
2. 返回结构化的 JSON 响应，包含清晰的错误信息

**修改前**：
```typescript
return NextResponse.json(
  {
    ok: false,
    errorCode: "DEPRECATED_ROUTE",
    message: "此路由已废弃。请使用前端直接调用 ai-service。前端应使用 callAiDirect() 函数。",
  },
  { status: 410 }
);
```

**修改后**：
```typescript
console.warn("[api/ai/ask] Deprecated route was called. It should no longer be used.");

return NextResponse.json(
  {
    ok: false,
    errorCode: "DEPRECATED_ROUTE",
    message: "AI API 已升级，当前端应直接调用 ai-service（callAiDirect），/api/ai/ask 已废弃。",
  },
  { status: 410 }
);
```

**验证**：
- ✅ 任何误调用会收到结构化 JSON（含 message），而不是只有 HTTP 410
- ✅ 控制台会输出警告日志

### ✅ 任务 5：确认心跳服务修复逻辑已生效

**文件**：`src/app/api/admin/ai/heartbeat/route.ts`

**确认要点**：

1. ✅ **环境变量使用**：
   - Local 使用：`AI_LOCAL_SERVICE_URL` + `AI_LOCAL_SERVICE_TOKEN`
   - Render 使用：`AI_RENDER_SERVICE_URL` + `AI_RENDER_SERVICE_TOKEN`

2. ✅ **超时设置**：
   - Local 超时：5 秒
   - Render 超时：10 秒

3. ✅ **错误处理**：
   - `AbortError` → `"Timeout (5s/10s)"`
   - `fetch failed` / `ECONNREFUSED` / `ENOTFOUND`：
     - 若是 localhost → `"Service not running or unreachable (localhost)"`
     - 否则 → `"Network error: xxx"`

4. ✅ **日志输出**：
   - 记录 url（截断）、hasToken、isLocalhost
   - 错误日志限制堆栈长度（500 字符）

**验证**：
- ✅ Local 未启动：`lastError` 为 `"Service not running or unreachable (localhost)"`
- ✅ Render 慢响应时：`lastError` 为 `"Timeout (10s)"`

## 三、代码变更清单

### 新建文件
1. `src/lib/aiEndpoint.ts` - AI 端点解析工具（公共 util）
2. `src/lib/aiProviderMapping.ts` - DB provider → 前端 provider 映射层

### 修改文件
1. `src/lib/aiClient.front.ts` - 改为从 `./aiEndpoint` 引入 `resolveAiEndpoint`
2. `src/lib/aiStatsClient.ts` - 使用公共的 `resolveAiEndpoint` 函数
3. `src/lib/aiProviderConfig.front.ts` - 使用 `mapDbProviderToClientProvider` 函数
4. `src/app/api/ai/ask/route.ts` - 优化 410 返回内容和日志
5. `src/app/api/admin/ai/heartbeat/route.ts` - 更新指令版本号

## 四、验收标准检查

### ✅ AI Stats 端点
- ✅ `getAiExpectedTime("local", ...)` → 使用 `NEXT_PUBLIC_LOCAL_AI_SERVICE_URL` 对应的地址
- ✅ `getAiExpectedTime("render", ...)` → 使用 `NEXT_PUBLIC_RENDER_AI_SERVICE_URL` 对应的地址

### ✅ 旧 provider 数据
- ✅ 若 DB 中某场景 `provider = "openai"` / `"openrouter"` / `"gemini"`：
  - 实际调用时会被映射为 `provider = "render"`
  - 不会再抛出 "endpoint not configured for provider: openai" 错误

### ✅ /api/ai/ask
- ✅ 任何误调用会收到结构化 JSON（含 message），而不是只有一个 HTTP 410
- ✅ 控制台会输出警告日志

### ✅ 心跳接口
- ✅ Local 未启动：`lastError` 为 `"Service not running or unreachable (localhost)"`
- ✅ Render 慢响应时：`lastError` 为 `"Timeout (10s)"`

## 五、测试建议

### 5.1 测试 AI Stats 端点

```typescript
// 测试 local provider
const localTime = await getAiExpectedTime("local", "llama3.2:3b");
// 应该使用 NEXT_PUBLIC_LOCAL_AI_SERVICE_URL

// 测试 render provider
const renderTime = await getAiExpectedTime("render", "gpt-4o-mini");
// 应该使用 NEXT_PUBLIC_RENDER_AI_SERVICE_URL
```

### 5.2 测试 Provider 映射

```typescript
// 测试映射函数
mapDbProviderToClientProvider("openai") // → "render"
mapDbProviderToClientProvider("openrouter") // → "render"
mapDbProviderToClientProvider("local") // → "local"
mapDbProviderToClientProvider("unknown") // → "render" (默认)
```

### 5.3 测试废弃路由

```bash
# 测试 /api/ai/ask 返回
curl -X POST http://localhost:3000/api/ai/ask \
  -H "Content-Type: application/json" \
  -d '{"question":"test"}'

# 应该返回：
# {
#   "ok": false,
#   "errorCode": "DEPRECATED_ROUTE",
#   "message": "AI API 已升级，当前端应直接调用 ai-service（callAiDirect），/api/ai/ask 已废弃。"
# }
```

### 5.4 测试心跳接口

1. **Local 服务未运行**：
   - 访问 `/api/admin/ai/heartbeat`
   - 验证 `lastError` 为 `"Service not running or unreachable (localhost)"`

2. **Render 服务超时**：
   - 如果服务响应慢，验证是否在 10 秒后超时
   - 验证 `lastError` 为 `"Timeout (10s)"`

## 六、已知限制

1. **场景配置表没有 provider 字段**：
   - 当前 `ai_scene_config` 表没有 `provider` 字段
   - 场景测试页面使用配置中心的全局 provider 配置
   - 如果需要每个场景独立配置 provider，需要添加数据库字段

2. **映射规则可能需要扩展**：
   - 如果未来有新的 provider 类型，需要在 `aiProviderMapping.ts` 中添加

## 七、后续优化建议

1. **场景级别的 Provider 配置**：
   - 考虑在 `ai_scene_config` 表中添加 `provider` 字段
   - 允许每个场景独立配置使用的 provider

2. **Provider 配置缓存**：
   - 可以考虑缓存 provider 配置，减少 API 调用

3. **更详细的错误信息**：
   - 在心跳接口中，可以提供更详细的诊断信息

## 八、调用点验证

### 8.1 getCurrentAiProvider 调用点

**已验证的调用点**：
1. ✅ `src/components/AIPage.tsx` - 使用 `getCurrentAiProvider()` 获取配置
2. ✅ `src/app/admin/ai/scenes/page.tsx` - 使用 `getCurrentAiProvider()` 获取配置

**映射流程**：
- `getCurrentAiProvider()` → 从配置中心读取 DB provider → `mapDbProviderToClientProvider()` → 返回 `"local" | "render"`

### 8.2 getAiExpectedTime 调用点

**已验证的调用点**：
1. ✅ `src/components/AIPage.tsx` - 传入 `currentProvider`（已通过映射）

**验证**：
- ✅ 所有调用都传入正确的 `AiProviderKey` 类型（`"local" | "render"`）
- ✅ 不再有硬编码的 provider 值

### 8.3 callAiDirect 调用点

**已验证的调用点**：
1. ✅ `src/components/AIPage.tsx` - 传入 `currentProvider`（已通过映射）
2. ✅ `src/app/admin/ai/scenes/page.tsx` - 传入 `provider`（已通过映射）

**验证**：
- ✅ 所有调用都传入正确的 `provider` 参数
- ✅ 不再有直接使用 DB provider 值的情况

## 九、总结

本次修复成功完成了所有任务：

1. ✅ **提取公共工具函数**：`resolveAiEndpoint` 现在可以在多个文件中复用
2. ✅ **修复 aiStatsClient**：现在按 provider 正确选择端点
3. ✅ **添加映射层**：DB provider 值可以正确映射到前端 provider
4. ✅ **优化废弃路由**：返回更友好的错误信息
5. ✅ **确认心跳服务**：修复逻辑已生效，错误处理更完善
6. ✅ **验证所有调用点**：确保所有调用都正确使用映射函数

### 关键改进

1. **代码复用**：
   - `resolveAiEndpoint` 现在可以在多个文件中复用
   - 减少了代码重复

2. **类型安全**：
   - 使用 `AiProviderKey` 类型确保类型安全
   - 映射函数确保不会传入无效的 provider 值

3. **向后兼容**：
   - 旧的 DB provider 值（如 `"openai"`, `"openrouter"`）可以正确映射
   - 不会因为旧数据导致崩溃

4. **错误处理**：
   - 更友好的错误信息
   - 更详细的日志输出

所有代码已通过 linter 检查，可以开始测试。

