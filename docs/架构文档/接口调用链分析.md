# 接口调用链分析

## 问题：场景测试和实际使用的接口是否一致？

### 1. 场景测试（`src/app/admin/ai/scenes/page.tsx`）

**调用链：**
```
场景测试页面
  → callAiDirect (前端, src/lib/aiClient.front.ts)
    → 直接调用 AI 服务的 /v1/ask 端点
```

**请求体格式：**
```json
{
  "question": "用户输入的原始文本",  // ⚠️ 原始文本
  "lang": "zh",
  "scene": "question_translation",
  "sourceLanguage": "zh",
  "targetLanguage": "en",
  "model": "..."
}
```

**特点：**
- 前端直接调用 AI 服务
- `question` 字段是用户输入的原始文本
- 使用前端环境变量（`NEXT_PUBLIC_AI_LOCAL_SERVICE_URL` 等）

---

### 2. 题目管理页面 - 翻译（`src/app/admin/questions/page.tsx`）

**调用链：**
```
题目管理页面
  → /api/admin/question-processing/translate (后端 API)
    → translateWithPolish (src/app/api/admin/question-processing/_lib/batchProcessUtils.ts)
      → callAiAskInternal
        → callAiServer (后端, src/lib/aiClient.server.ts)
          → AI 服务的 /v1/ask 端点
```

**请求体格式：**
```json
{
  "question": "Content: 题干内容\nOptions:\n- 选项1\n- 选项2\nExplanation: 解析内容",  // ⚠️ 格式化后的文本
  "lang": "en",
  "scene": "question_translation",
  "sourceLanguage": "zh",
  "targetLanguage": "en",
  "model": "..."
}
```

**特点：**
- 后端 API 调用
- `question` 字段是格式化后的文本（包含 `Content:`, `Options:`, `Explanation:` 前缀）
- 使用服务端环境变量（`AI_LOCAL_SERVICE_URL` 等）

---

### 3. 题目管理页面 - 润色（`src/app/admin/questions/page.tsx`）

**调用链：**
```
题目管理页面
  → /api/admin/question-processing/polish (后端 API)
    → question-processor 服务 /polish 端点
      → polishContent (apps/question-processor/src/ai.ts)
        → callQuestionAi
          → callAiServer (后端, src/lib/aiClient.server.ts)
            → AI 服务的 /v1/ask 端点
```

**请求体格式：**
```json
{
  "question": "Language: zh\nContent: 题干内容\nOptions:\n- 选项1\n- 选项2\nExplanation: 解析内容",  // ⚠️ 格式化后的文本
  "lang": "zh",
  "scene": "question_polish",
  "model": "..."
}
```

**特点：**
- 后端 API 调用，经过 question-processor 服务
- `question` 字段是格式化后的文本（包含 `Language:`, `Content:`, `Options:`, `Explanation:` 前缀）
- 使用服务端环境变量（`AI_LOCAL_SERVICE_URL` 等）

---

## 关键差异

### ❌ 问题 1：question 字段格式不一致

- **场景测试**：使用原始文本
- **实际翻译/润色**：使用格式化后的文本（包含前缀）

### ❌ 问题 2：环境变量可能不同

- **场景测试**：使用前端环境变量（`NEXT_PUBLIC_*`）
- **实际翻译/润色**：使用服务端环境变量（无 `NEXT_PUBLIC_` 前缀）

### ✅ 相同点

- 都调用同一个 AI 服务的 `/v1/ask` 端点
- 都传递 `scene`, `sourceLanguage`, `targetLanguage` 等参数
- 都使用相同的 prompt 配置（从数据库读取）

---

## 结论

**场景测试和实际使用的接口不完全一致！**

主要差异在于：
1. `question` 字段的格式不同（原始文本 vs 格式化文本）
2. 环境变量来源不同（前端 vs 服务端）

这可能导致：
- 场景测试的结果与实际使用的结果不一致
- 测试无法准确反映实际使用情况

---

## 建议修复方案

### 方案 1：统一 question 格式（推荐）

修改场景测试，使其也使用格式化后的文本：

```typescript
// 在场景测试中，根据场景类型格式化 question
const formattedQuestion = scene.scene_key === 'question_translation' 
  ? `Content: ${requestBody.question}\nOptions:\n- 选项1\nExplanation: 解析`
  : scene.scene_key === 'question_polish'
  ? `Language: ${requestBody.locale}\nContent: ${requestBody.question}`
  : requestBody.question;
```

### 方案 2：让场景测试也经过后端 API

修改场景测试，使其调用后端 API 而不是直接调用 AI 服务：

```typescript
// 场景测试调用后端 API
const response = await fetch('/api/admin/question-processing/translate', {
  method: 'POST',
  body: JSON.stringify({
    questionId: testQuestionId,
    from: requestBody.sourceLanguage,
    to: requestBody.targetLanguage,
  }),
});
```

这样可以确保测试和实际使用完全一致。

