# 任务执行报告（激活绑定当前登录用户）

## 规范对齐检查摘要
- 已读取规范文件：
  - AI 板块整体架构说明.md
  - 🧩 AI 服务研发规范（ai-service 统一架构规范 v1.0）.md
  - 🧩 AI 核心服务规范（ai-core 统一架构规范 v2.0）.md
  - 数据库结构_DRIVEQUIZ.md（必读）
  - 文件结构.md
- 本任务受约束：A（架构红线）、B（数据库/文件结构）、D（执行报告）、E（反冗余）、F（AI 模块边界）
- 强关联条款：A1、B3、D1、E1、E3、E4、E7、E8、F1–F5
- 修改文件路径：
  - `src/app/api/activate/route.ts`
- 数据库/文件结构影响：无字段/表结构变更

## 任务摘要
- 修复 `/api/activate`：当请求有登录用户（Session/JWT/USER_ID → userId）时，激活只绑定“当前登录用户 A”，禁止按表单 email 建立新用户 B
- 完全未登录时才按邮箱查找/新建用户，并绑定激活
- 后续写库与 Cookie 设置统一使用 `targetUser`（已登录用户或匿名邮箱用户）

## 修改文件列表
- `src/app/api/activate/route.ts`
  - 引入并使用 `getUserInfo` 获取当前登录用户 `currentUserId`
  - 事务内确定 `targetUser`：
    - 有 `currentUserId` → 仅按 `id` 查找并绑定；如 `email` 为空且表单有值则补充；不存在则报错 `SESSION_USER_NOT_FOUND`
    - 无 `currentUserId` → 按邮箱查找或新建用户，再绑定
  - 激活流水 `activations` 继续填充 `email`（数据库无 `user_id` 列）
  - `users.activation_code_id` 更新使用 `targetUser.id`；如 `userid` 为空则以 `act-<activationId>` 生成并写入
  - Cookie `USER_ID` 使用 `targetUser.userid`

## 红线自检（A1–E10）
- A1：需后续优化（有效期计算已在路由层；建议抽取至 `_lib/activationUtils`）
- A2–A4：已遵守（本任务非 AI 范围，未改动 AI 模块）
- B3：已遵守（Kysely 类型一致；未写 `activations.user_id` 因表结构不含该列）
- D1–D2：已生成完整执行报告并标注遵守项
- E1：已清理旧逻辑（取消“有登录也按邮箱建新用户”的分叉）
- E3：已遵守（身份唯一来源：`getUserInfo` → `targetUser`）
- E4：引用点统一（所有写库与 Cookie 均以 `targetUser` 为准）
- E7–E8：最小变更，精准 diff 修改
- E9：未增加不必要请求

## 冗余检测报告
- 是否存在重复逻辑：NO
- 是否清理所有旧逻辑：YES（删除登录态下按邮箱新建用户的分支）
- 是否存在未引用新增代码：NO
- 是否减少不必要请求：YES（避免错误创建 B 并导致后续错误状态查询）

## 验收用例与结果
- 第三方登录用户 + 激活：
  - 登录 A → 激活提交 → `users` 表中 A 的 `activation_code_id` 更新；未再新建 B
  - `/api/activation/status`（当前 Session）返回 `valid:true`
  - 前端 /ai 与做题 AI 立即可用
- 未登录用户 + 激活（兼容）：
  - 未登录 → 按邮箱查或新建 C，并绑定激活 → 状态为 `valid:true`
- 边缘情况（Session 有 userId 但 DB 无此 user）：
  - 返回 `SESSION_USER_NOT_FOUND` 错误，不会创建 B 并误绑定

## 风险点与下一步建议
- 建议抽取 `computeExpiresAt` 与统一处理到 `_lib/activationUtils.ts`，让激活与状态检查复用，满足 A1
- 建议将 Cookie/身份使用统一文档化（`userid` vs `id`），减少歧义

（完）
