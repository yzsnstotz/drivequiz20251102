目标：

彻底去掉之前 v2/v3 为 pg 写的复杂 pg.defaults.ssl / pgSslDefaults 补丁；

确保所有数据库连接只依赖 DATABASE_URL，不再对 host 做任何手工覆盖；

搜索并删除任何可能把 host 设置为 'base' 的代码或 pg.defaults.host 操作；

保持代码简洁，避免继续膨胀。

关键思路：
现在我们已经改用 Supabase 主库（db.***.supabase.co:5432），证书是正规 CA，不需要任何自定义 SSL 补丁，只要 ?sslmode=require 就可以愉快连上。
把之前为 pooler 写的 hack 全部删掉，问题自然消失。

步骤 1：删除统一 SSL 补丁模块

删除文件（如果存在）：

src/lib/pgSslDefaults.ts

全局搜索：

initPgSslDefaults

pgSslDefaults

pg.defaults.ssl

pg.defaults.host

"base"（字符串）

并做如下处理：

所有对 initPgSslDefaults(...) 的调用 全部删除；

如果有代码设置过 pg.defaults.host = "base" 或类似操作，必须删除；

不得再出现任何 pg.defaults.ssl = ... 之类的设置。

步骤 2：简化 src/lib/db.ts（或项目中用于 NextAuth 的 DB 客户端）

用最简单、标准的方式创建 Kysely + Pool，不做任何花活。

假设现在是类似结构（Cursor 自己按实际文件路径修正）：

// src/lib/db.ts
import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";

const connectionString = process.env.DATABASE_URL;
// 旧代码：各种 buildDbSslConfig / initPgSslDefaults / hasSSL / sslConfig 等逻辑

const pool = new Pool({
  connectionString,
  // ❌ 不要自己传 host / ssl / port 等，只交给 connectionString
});

export const db = new Kysely<Database>({
  dialect: new PostgresDialect({ pool }),
});


具体要求：

删除所有以下内容：

buildDbSslConfig() 函数；

任何 ssl 相关字段（ssl: xxx）；

任何 hasSSL / sslConfig / DB_CA_CERT 逻辑；

任何 initPgSslDefaults() 调用或导入。

Pool 的配置只保留必需字段：

const pool = new Pool({
  connectionString,
  max: 20,                  // 可选：连接池大小
  idleTimeoutMillis: 30000, // 可选：空闲超时
  connectionTimeoutMillis: 10000, // 可选：连接超时
});


禁止在这里设置：

host

port

database

user

password

ssl

这些都由 connectionString 自动解析。

保留一条简单日志，方便你自己看：

if (!connectionString) {
  throw new Error("[DB][Config] DATABASE_URL is not set");
}

console.log(
  "[DB][Config] Using DATABASE_URL (first 80 chars):",
  connectionString.substring(0, 80) + "..."
);

步骤 3：确保 NextAuth Adapter 只使用这个 db，不创建其他 Pool

检查 src/lib/auth-kysely-adapter.ts：

不允许出现 new Pool(...)、new Kysely(...)。

只能接受一个从 src/lib/db.ts 导入的 db 实例。

示例（目标形态）：

import { db } from "@/src/lib/db";
import { KyselyAdapter } from "@auth/kysely-adapter";

export const authAdapter = KyselyAdapter(db as any);


检查 src/lib/auth.ts 或 src/app/api/auth/[...nextauth]/route.ts 中的配置：

import { authAdapter } from "@/src/lib/auth-kysely-adapter";

export const authOptions: NextAuthConfig = {
  adapter: authAdapter,
  // ...其他配置
};


全局搜索：

new Kysely(

new PostgresDialect(

new Pool(

允许存在的位置只有：

src/lib/db.ts（主业务库）

若有其他完全独立服务（比如 AI 向量库），也要各自简化为同样模式，不得再设置 host 为 "base"。

步骤 4：检查环境变量中是否有错误的 PG 默认值

虽然这一步不是 Cursor 能改的，但你可以自己在 Vercel 后台确认一下：

打开 Vercel → Project → Settings → Environment variables

搜索以下变量是否存在：

PGHOST

PGPORT

PGDATABASE

PGUSER

PGPASSWORD

如果有 PGHOST=base 或类似，直接删掉（或改成正确的 Supabase host）。

因为 pg 客户端在没有 host 的时候会 fallback 到 PGHOST，
如果某处被自动注入了 PGHOST=base，就会导致你现在这个 ENOTFOUND base。

保留的只需要：

DATABASE_URL=postgresql://...@db.***.supabase.co:5432/postgres?sslmode=require

SUPABASE_URL（给 Supabase JS 用）

其他与你业务相关的 env。

步骤 5：验收步骤（Cursor 必须写进新的执行报告）

部署后，先看日志里有没有类似：

[DB][Config] Using DATABASE_URL (first 80 chars): postgresql://postgres:***@db.vdtnzjvmvrcdplawwiae.supabase.co:5432/postgres?sslmode=require...


确认不再出现：

self-signed certificate in certificate chain

hostname: 'base'

pg.defaults.ssl 相关日志

再次尝试：

Google 登录

LINE 登录

X 登录

预期：

OAuth 回调完成；

日志内 getUserByAccount 不再抛 AdapterError；

前端真的显示为“已登录”。