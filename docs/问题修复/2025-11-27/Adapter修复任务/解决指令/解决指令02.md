NextAuth Adapter SELF_SIGNED_CERT_IN_CHAIN 修复 + DB SSL 配置收口（v2）

1. 问题结论（写在执行报告开头）

OAuth 链路（Google / LINE / X）已经正常完成授权和回调。

回调后在 getUserByAccount 时，NextAuth Adapter 内部访问数据库报错：

[NextAuth][AdapterError][cause] {
  err: Error: self-signed certificate in certificate chain
    at async k.acquireConnection ...
    code: 'SELF_SIGNED_CERT_IN_CHAIN'
}


说明：

数据库连接本身是 TLS 必须校验证书 的环境（例如 Supabase），

当前 Kysely / pg 的客户端没有正确配置 SSL，

全局的 NODE_TLS_REJECT_UNAUTHORIZED=0 已经被移除，所以 TLS 校验现在暴露为 AdapterError。

2. 需要修改的范围（只动 DB 配置链路）

禁止修改：

ai-service、drivequiz-api 等其他服务；

再次引入或修改 NODE_TLS_REJECT_UNAUTHORIZED；

NextAuth 核心配置（adapter / providers / logger 除了必要日志外不动）。

只允许修改：

为 NextAuth Adapter 使用的 DB/Kysely 客户端所在模块，例如（具体路径请 Cursor 自行确认）：

src/lib/db.ts

或 src/server/db.ts

或 src/lib/kysely.ts

若有专门的 createPatchedKyselyAdapter 模块引用 DB 实例，例如：

src/lib/auth-kysely-adapter.ts

要求：最终 NextAuth 的 Adapter 只用一个统一配置好的 DB 客户端，这个客户端里正确处理了 SSL。

3. 具体实现步骤
3.1 定位 DB 客户端和 Dialect 初始化

全局搜索 new PostgresDialect 或 new Pool 或 createKysely 关键字，找到负责创建 DB 实例的模块。

找出 NextAuth 用的那个 DB 实例：

在 src/lib/auth-kysely-adapter.ts 中，查它是怎么拿 db 的，比如：

import { db } from "@/src/lib/db";
export const adapter = createPatchedKyselyAdapter(db);


沿着这个 db 追踪到创建的地方（通常就是 src/lib/db.ts）。

3.2 在 DB 客户端中集中处理 SSL 配置

以使用 pg + kysely 为例，改造为这样的结构（伪代码，Cursor 要根据项目实际写成 TS）：

// src/lib/db.ts 示例

import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";
// 如果需要类型： import type { TLSOptions } from "tls";

const isProd = process.env.NODE_ENV === "production";
const connectionString = process.env.DATABASE_URL ?? process.env.DRIVEQUIZ_DB_URL;

// 统一的 SSL 配置函数
function buildDbSslConfig() {
  if (!isProd) {
    // 本地开发直连，无 SSL
    return false;
  }

  // 优先使用 CA 证书（更安全）
  if (process.env.DB_CA_CERT) {
    return {
      ca: process.env.DB_CA_CERT,
    };
  }

  // 没有提供 CA 时，退而求其次，只对 DB 连接关闭证书严格校验
  return {
    rejectUnauthorized: false,
  };
}

const ssl = buildDbSslConfig();

console.log("[DB][Config] Using SSL config:", {
  enabled: !!ssl,
  mode: typeof ssl === "object" ? "custom" : "disabled",
});

const pool = new Pool({
  connectionString,
  ssl, // 关键：在这里传入 ssl 配置，而不是靠 NODE_TLS_REJECT_UNAUTHORIZED
});

export const db = new Kysely<DBSchema>({
  dialect: new PostgresDialect({ pool }),
});


要求：

如果项目已经有类似 hasSSL / sslConfig 之类变量，请统一收口到一个 buildDbSslConfig() 函数里，不要多处散落。

删除老的、未被使用的 SSL 配置信息和重复日志（下面第 4 点会专门做清理）。

安全层级建议（已经在上面代码体现）：

最佳：你后面自己在环境变量里提供 DB_CA_CERT（Supabase 提供的 ca.pem 内容），我们就严格校验；

当前权衡：如果你暂时不想折腾 CA，就用 rejectUnauthorized: false，但只作用于 DB 连接，不再污染全局 HTTPS。

3.3 确保 NextAuth 使用的就是这个 DB 实例

检查 src/lib/auth-kysely-adapter.ts（参考执行报告里提到的文件路径）：

确认它没有自己新建其他 Kysely 实例，而是引用统一的 db：

import { db } from "@/src/lib/db";

export function createPatchedKyselyAdapter() {
  return KyselyAdapter(db);
}


如果发现它内部又建了一个 new Kysely(...)，要改为复用 db，避免出现 “一个用了 ssl，一个没用 ssl” 的情况。

4. 清理无用 / 冗余的 SSL 相关代码

在完成上面的收口后，让 Cursor 做一次「以 TLS / SSL 为关键词」的瘦身：

全局搜索：

hasSSL

sslConfig

rejectUnauthorized

NODE_TLS_REJECT_UNAUTHORIZED

SSL enabled for Supabase connection 之类的旧日志内容

对这些发现逐个处理：

如果是旧的 DB 配置片段、没再被引用，删除；

如果是多个地方在打印类似的 SSL 日志，合并到 buildDbSslConfig 附近的一条；

确认项目中不再有任何地方设置或依赖 NODE_TLS_REJECT_UNAUTHORIZED。

在执行报告里列一张“小表”，说明：

文件	删除/合并内容	原因
src/lib/db.ts	旧的 hasSSL / sslConfig 变量	已由 buildDbSslConfig 统一替代
...	...	...
5. 验收步骤（Cursor 要写进新的执行报告）

完成代码修改后，请 Cursor 按下面步骤做“最小完备验证”，并把结果写进 AdapterError修复_执行报告_v2.md 中：

本地或 Preview 环境验证（可选）

在一个能访问 DB 的环境下跑一次 OAuth 登录（例如 Google）。

确认日志中：

不再出现 SELF_SIGNED_CERT_IN_CHAIN；

有 [DB][Config] Using SSL config: ... 日志，说明 DB SSL 配置生效。

生产环境部署后验证

用 https://ai.zalem.app，分别测试：

Google 登录；

LINE 登录；

X 登录。

期望结果：

都可以正常跳转回站内，不再出现 AdapterError；

Vercel 日志中不再有 self-signed certificate in certificate chain。

安全与冗余检查

搜索确认：

没有再设置 NODE_TLS_REJECT_UNAUTHORIZED；

SSL 只在 DB 客户端中配置一次；

没有多余的旧日志或未使用的 SSL 变量。