先说结论：
这次问题本质上有两块——**AI 返回 JSON 的容错 / 清洗不彻底** 和 **目标语言过滤只在使用阶段做，没在 sanitize 阶段收紧**。下面是一份「一次性修完」的 Cursor 任务单，你可以直接贴给 Cursor 跑。

---

## 🧾 任务标题

> 批量处理 JSON 容错 + 目标语言过滤 · 一次性修复任务单 v1.0

---

## 0. 全局约束（不用改代码，只是提醒）

1. **严格遵守研发规范**

   * 业务逻辑放在 `_lib` 工具层，不写在 route.ts 里。
   * 如涉及 ai-core 调用，逻辑必须走 ai-core 抽象（本次主要改 question-processing，不额外牵涉 ai-core）。

2. **数据库事实来源**（只读，不改结构）

   * `questions` 表中的 `content / explanation / options / correct_answer` 均为 JSONB 字段，必须保证写入是合法 JSON，不能出现 `undefined`。
   * ai-service 端的 `ai_scene_config / ai_provider_config` 等表结构不变，本次不改 ai-service，只在 DriveQuiz 侧消费结果。

---

## 1. JSON 清理工具：统一实现 `cleanJsonString` + JSONB 规范化

### 1.1 新增工具函数文件

**目标：** 所有 AI 返回的 “JSON 字符串” 在 `JSON.parse` 之前都先走一遍清洗；所有要写入 DB 的 JSONB 对象先统一做 `undefined` 清理。

1. 在包含 `src/app/api/admin/question-processing` 的 Next.js 应用中（通常是 `apps/web` 或等价目录），新增工具文件：

**路径示例：**

* `src/app/api/admin/question-processing/_lib/jsonUtils.ts`

**实现内容：**

````ts
// jsonUtils.ts

/**
 * 清理 AI 返回的 JSON 字符串，使其尽量符合标准 JSON 语法：
 * - 去掉 Markdown 代码块包裹
 * - 去掉 BOM / 隐藏字符
 * - 去掉对象/数组结尾处的尾随逗号
 */
export function cleanJsonString(input: string): string {
  if (!input) return input;

  let s = input.trim();

  // 去掉 UTF-8 BOM / 零宽空格
  s = s.replace(/^[\uFEFF\u200B]+/, '');

  // 去掉 ```json / ``` 包裹
  s = s.replace(/^```(?:json)?\s*/i, '').replace(/```$/i, '').trim();

  // 去掉对象 / 数组 结尾处的尾随逗号: {...,} / [...,]
  s = s.replace(/,\s*([}\]])/g, '$1');

  return s;
}

/**
 * 递归清理将要写入 JSONB 字段的数据：
 * - 移除所有值为 undefined 的属性
 * - 数组元素中的 undefined 直接丢弃
 * - 保证只包含 JSON 支持的类型（string/number/boolean/null/object/array）
 */
export function sanitizeJsonForDb<T>(value: T): T | null {
  if (value === undefined) return null;
  if (value === null) return null;

  if (Array.isArray(value)) {
    const arr = value
      .map((v) => sanitizeJsonForDb(v))
      .filter((v) => v !== null) as any[];
    return arr as any;
  }

  if (typeof value === 'object') {
    const obj: any = {};
    for (const [k, v] of Object.entries(value as any)) {
      const sanitized = sanitizeJsonForDb(v as any);
      if (sanitized !== null) {
        obj[k] = sanitized;
      }
    }
    return obj as T;
  }

  // 基本类型：string / number / boolean
  if (
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean'
  ) {
    return value;
  }

  // 其他类型一律丢弃
  return null;
}
````

---

### 1.2 在所有 AI JSON 解析前接入 `cleanJsonString`

**目标：** 避免因为尾随逗号、代码块包裹等导致的 `invalid input syntax for type json`。

1. 打开：

   * `src/app/api/admin/question-processing/_lib/batchProcessUtils.ts`

2. 搜索所有对 AI 文本做 `JSON.parse(...)` 的位置（通常出现在 full_pipeline / translate 的解析阶段，例如 `parseFullPipelineResponse`、`parseAiJsonFromResponse` 之类的函数）。

3. 对“字符串来源的 JSON.parse”统一改成如下模式（伪代码示例）：

```ts
import { cleanJsonString } from './jsonUtils';

// 原来:
// const parsed = JSON.parse(rawJsonString);

// 修改后:
const parsed = JSON.parse(cleanJsonString(rawJsonString));
```

**要求：**

* 只改解析 AI 返回字符串的地方，不要误改前端传入的普通 JSON（真正已经是对象的就不需要 `cleanJsonString`）。
* 如果有封装好的 `safeJsonParse` / `extractJsonFromResponse` 函数，则优先在那个封装函数里集中接入 `cleanJsonString`，避免到处改。

---

### 1.3 在 `saveQuestionToDb` 统一使用 `sanitizeJsonForDb`

**目标：** 保证写入 `questions` 表的 JSONB 字段不包含 `undefined`、异常类型。

1. 打开负责写题库的工具函数文件（报告中提到为 `lib/questionDb.ts`，实际路径一般类似）：

   * `src/lib/questionDb.ts` 或等价路径（搜 `saveQuestionToDb`）。

2. 找到 `saveQuestionToDb`（或等价函数）中组织写入 `questions` 表的地方，重点字段包括：

   * `content`（多语言题干 JSONB）
   * `explanation`（多语言解析 JSONB）
   * `options`（选项 JSONB）
   * `correct_answer`（答案 JSONB）

3. 在最终传给 Kysely / DB 之前，对这四个字段统一调用 `sanitizeJsonForDb`：

```ts
import { sanitizeJsonForDb } from '../app/api/admin/question-processing/_lib/jsonUtils';
// 按实际相对路径调整 import

// 示例改造：
const contentForDb = sanitizeJsonForDb(payload.content);
const explanationForDb = sanitizeJsonForDb(payload.explanation);
const optionsForDb = sanitizeJsonForDb(payload.options);
const correctAnswerForDb = sanitizeJsonForDb(payload.correct_answer);

await db
  .insertInto('questions')
  .values({
    // ...
    content: contentForDb,
    explanation: explanationForDb,
    options: optionsForDb,
    correct_answer: correctAnswerForDb,
    // ...
  })
  .onConflict(/* ... */)
  .execute();
```

4. 如有更新逻辑（`update`），也统一走 `sanitizeJsonForDb`。

---

### 1.4 在批量事务更新前做一次 JSON 可序列化性检查（轻量）

**目标：** 在代码层提前发现脏数据，而不是交给 Postgres 抛错。

1. 在 `batchProcessUtils.ts` 中提到的事务更新位置（诊断报告中约在 **第 2974-2982 行**，更新 `content / explanation` 的地方），在写入前增加一次轻量验证：

```ts
// 构造好新的 question 对象后，写入事务前：
const safeContent = sanitizeJsonForDb(updatedQuestion.content);
const safeExplanation = sanitizeJsonForDb(updatedQuestion.explanation);

// 轻量验证：能否被 JSON.stringify
JSON.stringify(safeContent ?? {});
JSON.stringify(safeExplanation ?? {});

// 然后才写入事务
await trx
  .updateTable('questions')
  .set({
    content: safeContent,
    explanation: safeExplanation,
    // ...
  })
  .where('id', '=', question.id)
  .execute();
```

> 注意：这里的 `JSON.stringify` 主要是用来早发现 `BigInt` 等不支持类型，正常情况下不应抛错。

---

## 2. 目标语言过滤：增强 `sanitizeAiPayload`，源头就收紧 translations

### 2.1 扩展 `sanitizeAiPayload` 函数签名

**目标：** 在 sanitize 阶段就按照 `targetLanguages` 做过滤，而不是等到 “使用时” 再过滤。

1. 打开：

   * `src/app/api/admin/question-processing/_lib/batchProcessUtils.ts`

2. 找到 `sanitizeAiPayload` 函数（报告中约在 **第 2310-2330 行**）。

3. 将函数签名从类似：

```ts
function sanitizeAiPayload(raw: any): SanitizedPayload { ... }
```

修改为（具体类型名称按现有代码微调）：

```ts
type SanitizeAiPayloadParams = {
  sourceLanguage: string;          // e.g. 'zh'
  targetLanguages?: string[];      // e.g. ['ja', 'en']，不传表示保留全部 translations
  scene?: string;                  // 可选：question_translation / question_full_pipeline 等
};

function sanitizeAiPayload(
  raw: any,
  params: SanitizeAiPayloadParams
): SanitizedPayload {
  const { sourceLanguage, targetLanguages, scene } = params;

  // 1) 原有字段清洗逻辑保留（difficulty/tags 等）

  // 2) translations 的过滤逻辑增强：
  const translations = raw?.translations ?? {};

  const allowedLangs =
    Array.isArray(targetLanguages) && targetLanguages.length > 0
      ? targetLanguages
      : Object.keys(translations);

  const filteredTranslations: Record<string, any> = {};
  for (const lang of allowedLangs) {
    if (translations[lang]) {
      filteredTranslations[lang] = translations[lang];
    }
  }

  // 3) 保证 source-language 对应的数据来源：
  // 如果 scene 是 full_pipeline，并且 AI 在 translations 里也返回了源语言，
  // 可以视需要保留 sourceLanguage 项：
  if (
    scene === 'question_full_pipeline' &&
    translations[sourceLanguage] &&
    !filteredTranslations[sourceLanguage]
  ) {
    filteredTranslations[sourceLanguage] = translations[sourceLanguage];
  }

  // 4) 将 filteredTranslations 写入 sanitized 对象
  const sanitized: SanitizedPayload = {
    // ...其他字段（stage_tags / topic_tags / difficulty_level / license_type_tags）
    translations: filteredTranslations,
  };

  return sanitized;
}
```

---

### 2.2 调整所有调用 `sanitizeAiPayload` 的位置，传入上下文参数

**目标：** 确保 full_pipeline / translate 等场景都正确透传 source & target 语言。

1. 在同一文件中搜索 `sanitizeAiPayload(` 调用点，常见有：

   * full_pipeline 流程解析 AI 响应
   * translate only 流程解析 AI 响应

2. 将原来类似：

```ts
const sanitized = sanitizeAiPayload(parsed);
```

统一修改为：

```ts
const sanitized = sanitizeAiPayload(parsed, {
  sourceLanguage,           // 该题目的源语言，如 'zh'
  targetLanguages,          // 当前任务配置的 targetLang 数组，如 ['ja'] 或 ['ja', 'en']
  scene: sceneKey,          // 比如 'question_full_pipeline' / 'question_translation'
});
```

> 说明：
>
> * `sourceLanguage` / `targetLanguages` / `sceneKey` 这些信息在构造 AI 请求和任务配置时已经有，请从现有上下文中取用（如 batch 任务的 options / full_pipeline 参数）。
> * 如果某些场景确实不区分 targetLanguages（如一次性生成多语言），可以不传 `targetLanguages`，让函数保留全部 translations。

---

### 2.3 精简下游使用逻辑：以 `sanitized.translations` 为唯一来源

**目标：** 保证后续构造 `translationsToSave` 时，不再需要重复过滤所有语言，而是只基于已过滤的 `sanitized.translations`。

1. 找到构建 `translationsToSave` 的逻辑（报告中提示在 **第 2667-2728 行**）。

2. 将现有逻辑改为：

```ts
// 原来的伪代码（示意）:
// const translations = sanitized.translations; // 但里面包含所有语言
// const translationsToSave = Object.entries(translations)
//   .filter(([lang]) => targetLanguages.includes(lang))
//   .map(...);

// 修改后的推荐写法：
const translations = sanitized.translations || {};
const translationsToSave = Object.entries(translations).map(
  ([lang, value]) => ({
    lang,
    value,
  })
);
// 不再在这里做 targetLanguages filter，因为 sanitize 已经保证只剩需要的
```

3. 如果你仍想做容错，可保留一次轻量 filter（但以防调用方忘记传 params）：

```ts
const translations = sanitized.translations || {};
const entries = Object.entries(translations);

const translationsToSave =
  Array.isArray(targetLanguages) && targetLanguages.length > 0
    ? entries
        .filter(([lang]) => targetLanguages.includes(lang))
        .map(([lang, value]) => ({ lang, value }))
    : entries.map(([lang, value]) => ({ lang, value }));
```

> 核心原则：**源头（sanitize）先收紧，使用处只是兜底**。

---

### 2.4 确保 explanation 也按目标语言过滤

很多场景里 AI 会在 `translations[lang].explanation` 下挂多语言解析，这部分也必须走 targetLang 过滤。

1. 检查 `sanitizeAiPayload` 内对 `translations[*].explanation` 的处理：

   * 确保只保留 `targetLanguages` 对应语言的 explanation。
   * 如果 AI 错误地在某个 language 节点下塞了别的语种文字，不在这里做复杂语言检测（那是 explanation 语言检测补丁的工作），这里只做**键过滤**。

2. 后续写入 DB 时，`questions.explanation` 仍然是多语言 JSONB，但是：

   * 当前操作只更新指定语言键值；
   * 不要覆盖其他语言已有的数据。

---

## 3. 兼容现有「解释语言检查」补丁

你之前已经让 Cursor 实现过 “explanation 语言占比检查（英 >30%，中 <10% 就跳过写入）” 的逻辑，这里不需要推翻，只需要确认以下两点：

1. 语言检查逻辑使用的是 **单一目标语言的文本**，而不是从未过滤的 translations 中随便取一个字段。
2. 在本次改完 `sanitizeAiPayload` 后，解释语言检查逻辑读取的字段、键名没有变化（否则需要同步调整）。

> 要求 Cursor 在执行完本任务后，**重新跑一次你之前用于复现 explanation 语言混乱的批量任务用例**，确认解释不会再写错语言。

---

## 4. 自测与回归建议（Cursor 必须在执行报告里体现）

1. **单元级自测（至少写在执行报告里，是否真正写测试由你决定）**

   * 用一个带尾随逗号和 ```json 包裹的字符串，验证 `cleanJsonString + JSON.parse` 不再报错。
   * 构造一个对象带 `undefined` 字段与数组，验证 `sanitizeJsonForDb` 后不再包含 undefined，数组中 undefined 被丢弃。
   * 构造 `raw.translations = { ja: {...}, zh: {...}, en: {...} }`，传入 `targetLanguages = ['ja']`，验证 `sanitizeAiPayload` 输出中只剩 `ja`（full_pipeline 场景可保留 sourceLanguage 例外）。

2. **集成级自测**

   * 本地起服务，选 2~3 道测试题，分别执行：

     1. `full_pipeline`，源语言 zh，目标语言 ja；
     2. 单独 `translate`，源语言 zh，目标语言 en；
   * 确认：

     * 批量任务不再因为 JSON 解析错误失败；
     * `questions.content / explanation` 中只新增 /更新目标语言对应的键；
     * 没有多余语言键被误写入；
     * Postgres 日志中没有新的 `invalid input syntax for type json` 报错。

3. **执行报告要求**

   * 明确列出：

     * 新增文件 / 修改文件列表；
     * 每个改动点对应的函数名 / 行为说明；
     * 用于自测的题目 ID、操作参数、预期结果与实际结果对比。

---

你可以直接把这整份「任务单」贴给 Cursor 作为下一轮任务输入。
如果 Cursor 执行完有新的执行报告，你发给我，我再帮你做一次“代码/行为层”的复核。
