你这次要我做的事就是：**根据《全局服务冗余请求问题_诊断报告》给 Cursor 一次性、可落地的修复指令，重点解决「身份验证 & 批量处理」的冗余 DB 请求问题**。

下面直接给一段可以丢给 Cursor 的任务说明（保持你现有流程：指令头 v5 + 本次任务内容）。

---

## ✅ 给 Cursor 的修复指令（可直接粘贴到 Cursor 任务里）

> 说明：本任务对应 Issue ID: **CP-20251202-003 全局服务冗余请求问题**，目标是减少全局身份验证和批量处理的冗余数据库访问，降低连接池压力和响应时间。

---

### 0. 指令头

在本任务开头，**先完整粘贴**《修复指令头05版（现用）.md》的内容（即：指令头 v5.0）。

---

### 1. 规范对齐检查摘要（Cursor 必须先输出）

> 以下内容请由 Cursor 在真正改代码之前先输出一段 5–8 行的「规范对齐检查摘要」，参考：

1. 已阅读规范文件：

   * `/Users/leo/Desktop/drivequiz研发规范/🧩 AI 服务研发规范（ai-service 统一架构规范 v1.0）.md`
   * `/Users/leo/Desktop/drivequiz研发规范/🧩 AI 核心服务规范（ai-core 统一架构规范 v2.0）.md`
   * `/Users/leo/Desktop/drivequiz研发规范/数据库结构_DRIVEQUIZ.md` 
   * `/Users/leo/Desktop/drivequiz研发规范/数据库结构_AI_SERVICE.md`
   * `/Users/leo/Desktop/drivequiz研发规范/文件结构.md`
2. 本任务相关的红线条款：

   * 架构：A1（路由层禁止承载业务逻辑）
   * 数据库：B1、B3、B4（字段、Kysely 类型 & 文档一致）
   * 文件结构：B2
   * 执行报告：D1、D2
3. 本次任务会影响的文件（示例，Cursor 需再扫描确认）：

   * `src/app/api/_lib/withAdminAuth.ts`
   * `src/app/api/_lib/withUserAuth.ts`
   * `src/app/api/_lib/getUserInfo.ts`（如存在）
   * `apps/question-processor/src/app/api/admin/question-processing/batch-process/route.ts`
   * `apps/question-processor/src/lib/batchProcessUtils.ts`（或等效路径）
   * 如涉及 `/api/auth/session` 轮询：对应的前端组件文件（含 `'api/auth/session'` 文本的文件）

---

### 2. 整体目标（给 Cursor 的任务总纲）

1. **统一身份验证查询逻辑**：

   * 管理员认证：`withAdminAuth` 必须统一走 `getAdminInfo`，禁止重复写 SQL。
   * 用户认证：`getUserInfo` / `withUserAuth` 去掉「NextAuth + 手工 DB 再查一次」这种重复查询；同一个请求只允许一次用户信息查询。

2. **批量处理的查询降维**：

   * 在 **一个批次** 内，对题目数据（`questions` 表）只进行 **一次批量查询 + 内存缓存**，禁止在循环里重复用 `questionId` 单条查询。
   * 批量任务中所有需要题目本体（content/explanation/tags）的地方改用这份内存 Map。

3. **减少全局冗余 API 调用**：

   * 检查前端对 `/api/auth/session`、`/api/activation/status`、`/api/user/license-preference` 的轮询/重复调用，尽量改为：**初始化时请求 + 客户端缓存/全局状态**，禁止高频重复请求。

> 本任务属于「不改 Schema、不改 AI 服务、仅优化 Web & question-processor 查询逻辑」的范畴，**禁止**改动 ai-core、ai-service 的服务端代码（只可改调用方式）。

---

### 3. 身份验证部分修复（A1：统一 & 去重查询）

#### 3.1 统一管理员认证逻辑（withAdminAuth + getAdminInfo）

**涉及文件（示例）**

* `src/app/api/_lib/withAdminAuth.ts`
* `src/app/api/_lib/adminAuthUtils.ts` 或同文件中的 `getAdminInfo`

**目标：**

* `withAdminAuth` 不再直接写 SQL / Kysely 查询 admin 表，而是 **只调用 `getAdminInfo`**。
* `getAdminInfo` 自身负责：

  * 从 DB 查 `admins` 表（字段参考 `admins` 表文档）；
  * 做必要的缓存（见下方缓存策略）；
  * 校验 `is_active`、权限字段等。

**具体修改要求：**

1. **重构 withAdminAuth：**

   * 删除/禁用现在在 `withAdminAuth` 内部直接连 DB 的查询逻辑。
   * 改为类似伪代码（由 Cursor 落地为真实 TS）：

     ```ts
     import { getAdminInfo } from './adminAuthUtils';

     export async function withAdminAuth(handler: NextRequestHandler) {
       return async (req: NextRequest) => {
         const token = 从 header 或 cookie 读取 admin token;
         const admin = await getAdminInfo(token);
         if (!admin) {
           return NextResponse.json({ error: 'UNAUTHORIZED' }, { status: 401 });
         }
         // 不在这里再查数据库，admin 对象由 getAdminInfo 提供
         return handler(req, { admin });
       };
     }
     ```

2. **在 getAdminInfo 中实现轻量缓存（模块级 Map）：**

   * 建一个简单的 in-memory cache：

     ```ts
     const adminCache = new Map<string, { admin: AdminRow; expiresAt: number }>();
     const ADMIN_CACHE_TTL_MS = 10_000; // 10秒
     ```
   * 查询逻辑：

     * 先查 `adminCache`，命中且未过期则直接返回；
     * 未命中再用 Kysely 查 `admins` 表（仅一次），拿到结果后写入缓存；
     * 若 admin 不存在 / inactive，缓存一个「空结果」也设置 TTL，避免暴力探测打 DB。

3. **确保不破坏权限模型：**

   * `getAdminInfo` 必须继续校验 `is_active`，以及（如有）`permissions` JSONB；字段名以 `数据库结构_DRIVEQUIZ.md` 为准。

---

#### 3.2 用户认证逻辑去重（getUserInfo + withUserAuth）

**涉及文件（示例）**

* `src/app/api/_lib/withUserAuth.ts`
* `src/app/api/_lib/getUserInfo.ts` 或同类工具
* 与 `getUserInfo` 强耦合的各 API route

**问题回顾（来自诊断报告）：**

* `getUserInfo` 先调用 NextAuth 的 `auth()` 做 session 查询（会触发 DB）。
* 之后又在 JWT 验证 / 激活 token 校验时再次对 `users` / `activations` 查库。
* 导致 **一次 API 请求多次查用户相关表**。

**修复目标：**

* 同一 HTTP 请求中：

  * `auth()` 最多只调用一次；
  * 对 `users` 主表最多一次查询；
  * 激活 token 校验最多一次查询（并带短 TTL 缓存）。

**具体修改要求：**

1. **将「NextAuth session + 用户信息」合并为一次查询链：**

   * 在 `getUserInfo` 中，设计如下流程（Cursor 需根据实际代码调整）：

     1. 首先调用 `auth()` 获取 session；
     2. 若 session 存在且包含 `user.id`，直接用该 `id` 去查询 `users`（一次）；
     3. 若 session 不存在但请求中带有 JWT（如 `Authorization: Bearer`），则优先验证 JWT；验证成功后拿到 `userId`，再进行一次 `users` 查询；
     4. **严禁**在其它地方再对同一个 `userId` 重复 `SELECT`。

2. **请求级用户缓存：**

   * 在 `getUserInfo` 内实现函数级别的缓存：

     * 方式：在模块顶部维护一个 `WeakMap<Request, CachedUser>` 或用闭包变量缓存「上一次传入 req + 结果」，Cursor 可按实际框架能力选择；
     * 简化实现：在 `getUserInfo` 里用「静态变量」缓存最近一次 token 对应的用户，并在本次函数调用内复用。
   * 要求：

     * **不会跨请求泄露用户信息**（不要用无限大的全局 Map + 不区分 token）。
     * 即使用模块级 Map，也要 key 包含 token/JWT 值，并控制 TTL（例如 5 秒）。

3. **激活 token 校验缓存：**

   * 为激活 token 单独建立 `activationTokenCache`（key: token + email 或 token 本身，视实际逻辑而定），TTL 例如 60 秒。
   * `getUserInfo` 中，当检测到请求带 `X-Activation-Token`（或实际字段）：

     * 先查 cache；
     * cache 未命中时再查一次 DB；
     * 任何分支都不得在同一次请求流程中重复查 `activations` / `activation_codes`。

4. **排查所有使用 getUserInfo 的 API route：**

   * 用全局搜索 `getUserInfo(` / `withUserAuth(`；
   * 确认**没有 API 在拿到 user 之后又手写 Kysely 再查 `users` 获取同样字段**；
   * 如有，将其改为直接使用 `getUserInfo` 返回的 user 对象（增加类型定义，保证字段齐全）。

---

### 4. 批量任务查询优化（A2 + A3：预加载 & 合并查询）

**目标：**

* 对于某一次 `batch-process` 请求：

  * 所有涉及 `questions` 表的读取，**收敛为 1 次批量查询**；
  * 所有操作复用这份内存数据，禁止在循环里多次 `SELECT`。

**主要涉及文件（示例）：**

* `apps/question-processor/src/app/api/admin/question-processing/batch-process/route.ts`
* `apps/question-processor/src/lib/batchProcessUtils.ts`（实际命名按仓库为准）

#### 4.1 引入「批量预加载」函数

1. 新建（或修改已有）工具函数，例如：

   ```ts
   // apps/question-processor/src/lib/batchProcessUtils.ts

   import { db } from '../db'; // 实际路径按项目调整
   import { QuestionRow } from '../types'; // Kysely/类型以项目现有为准

   export async function loadQuestionsForBatch(questionIds: number[]) {
     if (!questionIds.length) return new Map<number, QuestionRow>();

     const rows = await db
       .selectFrom('questions')
       .selectAll()
       .where('id', 'in', questionIds)
       .execute();

     const map = new Map<number, QuestionRow>();
     for (const row of rows) {
       map.set(Number(row.id), row);
     }
     return map;
   }
   ```

   * `QuestionRow` 的字段必须与 `questions` 表 Schema 一致（`id`, `content`, `explanation`, `correct_answer`, `stage_tag`, `license_type_tag`, `topic_tags`, `type` 等）。
   * 禁止只查一部分字段导致后续再查。

2. 在批量处理主入口（`batch-process/route.ts`）中：

   * 当拿到本批次 `questionIds` 后，第一步调用 `loadQuestionsForBatch(questionIds)` 得到 `questionsById` Map；
   * 后续的 translate/polish/fill_missing/category_tags/full_pipeline 处理函数，**全部接收 `questionsById` 作为参数**。

#### 4.2 去除循环内单条查询

1. 在 `batchProcessUtils.ts` 及其调用链中，全局搜索：

   * `where('id', '=', questionId)`
   * `where('questions.id', '=', questionId)`
   * 或类似以 `questionId` 为条件的单条 `SELECT`；
2. 对以下场景全部改造为使用 `questionsById`：

   * 每个操作前读取最新 content/explanation 的地方；
   * translate 时再查 content/explanation 的地方；
   * 取消/恢复检查时查看题目当前状态的地方。

示例改造（伪代码）：

```ts
// 之前（错误示意）
for (const questionId of questionIds) {
  const question = await db.selectFrom('questions')...where('id', '=', questionId).executeTakeFirst();
  // ... 后续逻辑
}

// 之后（目标）
for (const questionId of questionIds) {
  const question = questionsById.get(questionId);
  if (!question) {
    // 记录错误到 task item / error_detail，不要再查一次
    continue;
  }
  // 使用 question 里的 content/explanation/license_type_tag 等全部字段
}
```

3. 确保事务范围只包「写操作」：

   * 若当前逻辑是在事务中做「读 + AI 调用 + 写」，请拆分：

     * 读：批量预加载（事务外）；
     * AI 调用：事务外；
     * 写：事务内（按题目写入时，可用小事务或批量写事务，但中间不再重复读）。

---

### 5. 减少全局 API 轮询 / 冗余调用

> 这一块属于「加分项」，用来解决诊断报告中 `/api/auth/session`、`/api/activation/status`、`/api/user/license-preference` 调用过多的问题。

**Cursor 操作步骤：**

1. **全局搜索前端代码中对这些路径的使用：**

   * `'api/auth/session'`
   * `'api/activation/status'`
   * `'api/user/license-preference'`

2. 对每个调用点进行判断：

   * 若是在 React 组件中 `useEffect` + `setInterval` 或轮询：

     * 尽量改为「页面加载时请求 1 次 + 触发特定事件时再请求」；
   * 若多个组件都分别请求同一信息（如 session）：

     * 收敛为一个全局状态（例：`useSession`、React Context 或 Zustand / Redux store），其它组件只读状态，不再单独 `fetch`。

3. 要求：

   * 不引入新依赖库；
   * 避免大规模重构，只做「调用次数」层面的优化。

---

### 6. 连接池配置调整（可选、谨慎）

在完成上面查询优化后，如果还有明显的连接池压力，可以**小幅**调整以下配置（Cursor 在改前必须在执行报告里给出理由）：

1. `src/lib/db.ts`（主库）：

   * 根据当前部署环境，**酌情**将 `max` 从 20 提升到 25 或 30；
2. `apps/question-processor/src/db.ts`：

   * 可将 `max` 从 10 调整到 15–20 之间。

> 注意：任何配置修改都必须在执行报告中说明变更原因与风险评估，并确认不会与 Render/Railway 的连接数上限冲突。

---

### 7. 测试要求

Cursor 必须在本地完成以下测试，并在执行报告中摘要说明：

1. **身份验证相关：**

   * 手动调用 3–5 个依赖 `withAdminAuth` 的管理端 API，确认：

     * 能正确识别有效/无效 admin token；
     * 日志中不再出现同一个请求多次查询 `admins` 的情况。
   * 手动调用 3–5 个依赖 `withUserAuth` / `getUserInfo` 的用户端 API，确认：

     * 登录状态下请求正常返回；
     * 未登录 / token 无效时能正确返回 401 / 403；
     * 通过日志确认同一请求生命周期内不会多次查询同一 user。

2. **批量任务：**

   * 在本地执行一次批量任务（例如 50–100 道题，含 translate + fill_missing + category_tags）：

     * 确认任务能正常完成；
     * 查看日志中对 `questions` 表的查询次数是否从「N 次」下降到接近「1 次（批量）」；
     * 确认处理结果写入数据库正确（不用逐题人工验证，但可抽查 3–5 条）。

3. **前端调用频率：**

   * 在浏览器打开管理后台和用户端首页，观察 30 秒内：

     * `/api/auth/session`、`/api/activation/status` 的调用次数是否明显减少；
     * 网络面板中的平均响应时间是否有下降（粗略观察即可）。

---

### 8. 执行报告要求

任务完成后，Cursor 必须在仓库中新增执行报告文件：

* 路径建议：
  `docs/问题修复/CP-20251202-003/执行报告/CP-20251202-003_全局服务冗余请求问题_执行报告_v1.md`

* 报告内容至少包括：

  1. 任务摘要（本次修复目标、涉及模块）
  2. 修改文件列表（含路径）
  3. 针对 A1–D2 红线规范逐条自检（标注：已遵守 / 不适用）
  4. 测试结果摘要（含关键命令/接口调用 & 成功情况）
  5. 如有配置变更，说明原因与风险评估
  6. 风险点与下一步建议（例如：后续可视化监控、慢查询统计等）

---

### 9. 版本号更新

按指令头 v5 的要求：

* 修改 `src/lib/version.ts` 中的 `BUILD_TIME` 为当前日期时间（日本时间），并在执行报告的摘要中记录当前版本号（例如 `2025-12-02T23:30:00+09:00`）。

---

如果你希望，我可以在下一步帮你把「预加载 questions 的批量函数」和「getUserInfo 优化」写成更接近最终代码的伪补丁版本，方便你直接让 Cursor 生成实现。
