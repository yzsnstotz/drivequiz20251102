# 对话历史中语言切换回中文问题诊断报告

**报告日期**: 2025-12-02  
**问题类型**: 对话历史处理与语言参数不一致  
**严重程度**: 中等  
**影响范围**: 所有使用对话历史的多轮对话场景

---

## 一、问题整体叙述

### 1.1 问题描述

用户反馈：第一次回复可以按照传递的语言回复，但是第二句开始又切换回中文了。

具体表现：
- **第一次对话**：主程序传递 `lang: "ja"`，AI 正确使用日文 prompt，返回日文回复 ✅
- **第二次对话**：主程序传递 `lang: "ja"`，但 AI 返回中文回复 ❌
- **后续对话**：继续返回中文回复，无法保持日文

### 1.2 问题影响

1. **用户体验差**：用户期望持续使用日文对话，但第二次回复后切换回中文
2. **语言不一致**：同一对话会话中，语言前后不一致
3. **功能受限**：多轮对话场景无法正确保持语言设置

### 1.3 问题场景

主要影响使用对话历史（`messages` 参数）的多轮对话场景：
- AI 聊天页面（`/ai`）
- 问题 AI 对话框（`QuestionAIDialog`）
- 其他使用对话历史的场景

---

## 二、问题原因分析

### 2.1 根本原因

**核心问题**：`buildMessages` 函数和 `runScene` 函数没有接收和处理对话历史（`messages` 参数），导致每次调用都只构建包含 system 和当前 user 消息的列表，忽略了历史对话。

### 2.2 代码位置与逻辑

#### 2.2.1 buildMessages 函数（问题所在）

**文件**: `apps/ai-service/src/lib/sceneRunner.ts`

```typescript:447:473:apps/ai-service/src/lib/sceneRunner.ts
export function buildMessages(opts: {
  sysPrompt: string;
  userPrefix: string;
  question: string;
  refPrefix: string;
  reference?: string | null;
  sceneKey?: string; // 场景标识，用于判断是否需要特殊处理
}): Array<{ role: "system" | "user" | "assistant"; content: string }> {
  const { sysPrompt, userPrefix, question, refPrefix, reference, sceneKey } = opts;
  
  // 对于翻译和润色场景，直接使用 question 作为用户消息，不添加前缀和 RAG 上下文
  if (sceneKey === "question_translation" || sceneKey === "question_polish") {
    return [
      { role: "system", content: sysPrompt },
      { role: "user", content: question },
    ];
  }
  
  // 其他场景：使用问答格式，包含 RAG 上下文
  return [
    { role: "system", content: sysPrompt },
    {
      role: "user",
      content: `${userPrefix} ${question}\n\n${refPrefix}\n${reference || "（無/None）"}`,
    },
  ];
}
```

**问题**：
- `buildMessages` 函数只构建了 system 和 user 消息
- 没有接收 `messages` 参数（对话历史）
- 每次调用都重新构建消息列表，忽略历史对话

#### 2.2.2 RunSceneOptions 接口（缺少 messages 字段）

**文件**: `apps/ai-service/src/lib/sceneRunner.ts`

```typescript:53:78:apps/ai-service/src/lib/sceneRunner.ts
export interface RunSceneOptions {
  sceneKey: string;
  locale: string;
  question: string;
  reference?: string | null;
  userPrefix: string;
  refPrefix: string;
  config: CommonConfig;
  providerKind: "openai" | "ollama";
  // OpenAI 相关
  aiProvider?: "openai" | "openrouter" | "gemini";
  model?: string;
  // OpenAI ServiceConfig（仅当 providerKind === "openai" 时使用）
  // 注意：使用 any 类型避免 local-ai-service 无法解析 ServiceConfig 类型
  serviceConfig?: any;
  // Ollama 相关（仅当 providerKind === "ollama" 时使用）
  ollamaBaseUrl?: string;
  ollamaModel?: string;
  // 占位符替换
  sourceLanguage?: string | null;
  targetLanguage?: string | null;
  // 温度设置
  temperature?: number;
  // 场景配置读取超时（可选，默认根据 providerKind 决定）
  sceneConfigTimeoutMs?: number;
}
```

**问题**：
- `RunSceneOptions` 接口中没有 `messages` 字段
- 无法传递对话历史给 `runScene` 函数

#### 2.2.3 runScene 函数（没有处理对话历史）

**文件**: `apps/ai-service/src/lib/sceneRunner.ts`

```typescript:738:803:apps/ai-service/src/lib/sceneRunner.ts
export async function runScene(
  options: RunSceneOptions
): Promise<SceneResult> {
  const { 
    sceneKey, 
    locale, 
    question, 
    reference, 
    userPrefix, 
    refPrefix, 
    config, 
    providerKind,
    aiProvider = "openai",
    model,
    ollamaBaseUrl,
    ollamaModel,
    sourceLanguage,
    targetLanguage,
    temperature = 0.4,
  } = options;

  // ... 省略其他代码 ...

  // 3. 构建消息
  const messages = buildMessages({
    sysPrompt,
    userPrefix,
    question,
    refPrefix,
    reference,
    sceneKey, // 传递场景标识，用于判断是否需要特殊处理
  });
```

**问题**：
- `runScene` 函数没有从 `options` 中解构 `messages`
- 直接调用 `buildMessages` 构建新消息列表，忽略历史对话

#### 2.2.4 local-ai-service 路由（处理了历史但未传递）

**文件**: `apps/local-ai-service/src/routes/ask.ts`

```typescript:519:520:apps/local-ai-service/src/routes/ask.ts
// 3) 处理对话历史
const history = processHistory(messages, maxHistory);
```

**问题**：
- `local-ai-service` 路由中有 `processHistory` 函数处理对话历史
- 但处理后的 `history` 没有传递给 `runScene` 函数
- `runScene` 调用时没有传递 `messages` 参数

#### 2.2.5 ai-service 路由（未处理对话历史）

**文件**: `apps/ai-service/src/routes/ask.ts`

**问题**：
- `ai-service` 路由的 `parseAndValidateBody` 函数没有解析 `messages` 参数
- 路由中没有处理对话历史的逻辑
- 完全忽略了 `messages` 参数

### 2.3 问题流程分析

#### 第一次对话（正常）

1. 主程序传递 `lang: "ja"` 和 `messages: []`
2. AI 服务接收 `lang: "ja"`，规范化得到 `requestedLang: "ja"`
3. 场景配置读取：`selectedLang: "ja"`，使用日文 prompt
4. `buildMessages` 构建消息：`[{ role: "system", content: "日文prompt" }, { role: "user", content: "用户问题" }]`
5. AI 模型收到日文 system prompt，返回日文回复 ✅

#### 第二次对话（问题）

1. 主程序传递 `lang: "ja"` 和 `messages: [{ role: "user", content: "问题1" }, { role: "assistant", content: "日文回复1" }]`
2. AI 服务接收 `lang: "ja"`，规范化得到 `requestedLang: "ja"`
3. 场景配置读取：`selectedLang: "ja"`，使用日文 prompt
4. **问题**：`buildMessages` 构建消息时，只包含 system 和当前 user 消息，**忽略了历史对话**
5. 构建的消息：`[{ role: "system", content: "日文prompt" }, { role: "user", content: "问题2" }]`
6. AI 模型收到：
   - 日文 system prompt（正确）
   - 但只有当前问题，没有历史对话上下文
   - **模型可能根据当前问题或默认行为，返回中文回复** ❌

### 2.4 为什么第二次会切换回中文？

可能的原因：
1. **缺少对话上下文**：AI 模型看不到之前的对话历史，无法理解语言上下文
2. **System prompt 语言与对话历史不匹配**：虽然 system prompt 是日文，但如果没有历史对话，模型可能无法保持语言一致性
3. **模型默认行为**：某些模型在没有明确语言上下文时，可能默认使用中文

---

## 三、日志信息

### 3.1 关键日志位置

#### 3.1.1 场景配置读取日志

**文件**: `apps/ai-service/src/lib/sceneRunner.ts`

```typescript:285:296:apps/ai-service/src/lib/sceneRunner.ts
console.log("[SCENE-RUNNER] 场景配置读取成功:", {
  sceneKey,
  locale,
  requestedLang,
  selectedLang,
  promptLength: finalPrompt.length,
  promptPreview: finalPrompt.substring(0, 200) + "...",
  duration: `${duration}ms`,
  hasZhPrompt: !!sceneConfig.system_prompt_zh,
  hasJaPrompt: !!sceneConfig.system_prompt_ja,
  hasEnPrompt: !!sceneConfig.system_prompt_en,
  outputFormat: sceneConfig.output_format,
});
```

**日志内容**：
- `requestedLang` - 请求的语言（如 "ja"）
- `selectedLang` - 实际选择的 prompt 语言（如 "ja"）

#### 3.1.2 消息构建日志

**文件**: `apps/ai-service/src/lib/sceneRunner.ts`

```typescript:808:817:apps/ai-service/src/lib/sceneRunner.ts
console.log("[SCENE-RUNNER] 准备调用模型:", {
  sceneKey,
  providerKind,
  model: providerKind === "openai" ? model : ollamaModel,
  hasResponseFormat: !!responseFormat,
  responseFormat,
  messageCount: messages.length,
  sysPromptLength: sysPrompt.length,
  sysPromptPreview: sysPrompt.substring(0, 200) + "...",
});
```

**日志内容**：
- `messageCount` - 消息数量（应该显示为 2，因为只有 system 和 user 消息）
- **问题**：日志中没有显示是否包含对话历史

#### 3.1.3 路由层日志

**文件**: `apps/ai-service/src/routes/ask.ts`

```typescript:354:359:apps/ai-service/src/routes/ask.ts
console.log("[ASK ROUTE] 使用场景执行模块:", {
  scene,
  locale: promptLocale,
  originalLang: lang,
  requestedLang,
  sourceLanguage,
  targetLanguage,
  model,
  aiProvider,
});
```

**日志内容**：
- `requestedLang` - 规范化后的请求语言
- **问题**：日志中没有显示是否传递了 `messages` 参数

### 3.2 日志分析

从日志可以看出：
1. **语言参数正确传递**：`requestedLang` 和 `selectedLang` 都是正确的（如 "ja"）
2. **System prompt 正确选择**：使用了对应语言的 prompt
3. **但消息列表不完整**：`messageCount` 始终为 2（system + user），没有包含历史对话
4. **缺少对话历史信息**：日志中没有显示是否传递了 `messages` 参数

---

## 四、之前采取过的措施详情

### 4.1 措施一：修复语言选择逻辑（最近）

**时间**: 2025-12-02

**位置**: 
- `apps/ai-service/src/lib/sceneRunner.ts`
- `apps/ai-service/src/routes/ask.ts`
- `apps/local-ai-service/src/routes/ask.ts`

**措施内容**：
- 添加 `normalizeRequestedLang` 函数，规范化语言参数
- 修复 prompt 选择逻辑，优先使用对应语言的 prompt
- 修复路由中的语言选择逻辑

**效果**：
- ✅ 第一次回复可以按照传递的语言回复
- ❌ 但没有解决对话历史中的语言切换问题

### 4.2 措施二：local-ai-service 中的 processHistory 函数

**位置**: `apps/local-ai-service/src/routes/ask.ts`

**措施内容**：
```typescript:315:343:apps/local-ai-service/src/routes/ask.ts
function processHistory(
  messages: ChatMessage[] | undefined,
  maxHistory: number = 10
): ChatMessage[] {
  if (!messages || messages.length === 0) {
    return [];
  }

  // 过滤无效消息
  const validMessages = messages.filter(
    (msg) =>
      msg &&
      msg.role &&
      msg.content &&
      typeof msg.content === "string" &&
      msg.content.trim().length > 0 &&
      (msg.role === "user" || msg.role === "assistant" || msg.role === "system")
  );

  // 只保留最近的 N 条消息（不包括 system）
  const nonSystemMessages = validMessages.filter((msg) => msg.role !== "system");
  const recentMessages = nonSystemMessages.slice(-maxHistory);

  // 如果原始消息中有 system 消息，保留第一个
  const systemMessages = validMessages.filter((msg) => msg.role === "system");
  const systemMessage = systemMessages.length > 0 ? [systemMessages[0]] : [];

  return [...systemMessage, ...recentMessages];
}
```

**问题**：
- `processHistory` 函数正确处理了对话历史
- 但处理后的 `history` 没有传递给 `runScene` 函数
- `runScene` 调用时没有传递 `messages` 参数

### 4.3 措施三：前端对话历史传递

**位置**: `src/components/AIPage.tsx`

**措施内容**：
```typescript:247:257:src/components/AIPage.tsx
// 准备对话历史（包含当前用户消息，因为状态更新是异步的）
const allMessages = [...messages, userMsg];

const historyMessages = allMessages
  .slice(-12)
  .filter((msg) => msg.role === "user" || msg.role === "ai")
  .slice(0, -1)
  .map((msg) => ({
    role: msg.role === "ai" ? "assistant" : "user" as "user" | "assistant",
    content: msg.content,
  }));
```

**问题**：
- 前端正确构建了对话历史
- 但后端没有正确处理这些历史消息

---

## 五、影响范围分析

### 5.1 受影响的功能

1. **AI 聊天页面** (`/ai`)
   - 多轮对话场景
   - 用户期望持续使用同一语言对话

2. **问题 AI 对话框** (`QuestionAIDialog`)
   - 多轮对话场景
   - 用户期望持续使用同一语言对话

3. **其他使用对话历史的场景**
   - 任何传递 `messages` 参数的多轮对话场景

### 5.2 受影响的服务

1. **ai-service** (远程AI服务)
   - 完全没有处理对话历史
   - `parseAndValidateBody` 函数没有解析 `messages` 参数

2. **local-ai-service** (本地AI服务)
   - 有 `processHistory` 函数处理对话历史
   - 但处理后的历史没有传递给 `runScene` 函数

### 5.3 受影响的主程序调用

1. **前端 AI 页面** (`src/components/AIPage.tsx`)
   - 传递了 `messages` 参数
   - 但后端没有正确处理

2. **问题 AI 对话框** (`src/components/QuestionAIDialog.tsx`)
   - 可能也传递了 `messages` 参数
   - 但后端没有正确处理

---

## 六、数据库配置情况

### 6.1 场景配置表结构

**表名**: `ai_scene_config`

**字段**:
- `system_prompt_zh` (text) - 中文系统提示词
- `system_prompt_ja` (text) - 日文系统提示词
- `system_prompt_en` (text) - 英文系统提示词
- `output_format` (text) - 输出格式
- `enabled` (boolean) - 是否启用

### 6.2 配置读取逻辑

**文件**: `apps/ai-service/src/lib/sceneRunner.ts`

**当前逻辑**：
- 根据 `requestedLang` 选择对应语言的 prompt
- 如果对应语言的 prompt 不存在，降级使用中文 prompt

**问题**：
- System prompt 的语言选择是正确的
- 但对话历史没有被包含在消息列表中
- 导致 AI 模型无法看到之前的对话上下文

---

## 七、问题总结

### 7.1 核心问题

**对话历史没有被传递给 AI 模型，导致多轮对话中语言切换回中文。**

### 7.2 问题根源

1. **架构设计缺陷**：
   - `buildMessages` 函数没有接收 `messages` 参数
   - `RunSceneOptions` 接口中没有 `messages` 字段
   - `runScene` 函数没有处理对话历史

2. **实现不完整**：
   - `local-ai-service` 有 `processHistory` 函数，但没有传递给 `runScene`
   - `ai-service` 完全没有处理对话历史

3. **语言上下文丢失**：
   - 虽然 system prompt 使用了正确的语言
   - 但缺少对话历史，AI 模型无法理解语言上下文
   - 导致第二次回复后切换回中文

### 7.3 修复方向

需要：
1. **扩展接口**：在 `RunSceneOptions` 中添加 `messages` 字段
2. **修改函数**：`buildMessages` 函数需要接收并处理对话历史
3. **更新路由**：`ai-service` 和 `local-ai-service` 路由需要传递对话历史
4. **保持语言一致性**：确保对话历史中的语言与 system prompt 语言一致

### 7.4 修复建议

1. **扩展 RunSceneOptions 接口**：
   ```typescript
   export interface RunSceneOptions {
     // ... 现有字段 ...
     messages?: Array<{ role: "system" | "user" | "assistant"; content: string }>; // 对话历史
   }
   ```

2. **修改 buildMessages 函数**：
   ```typescript
   export function buildMessages(opts: {
     sysPrompt: string;
     userPrefix: string;
     question: string;
     refPrefix: string;
     reference?: string | null;
     sceneKey?: string;
     messages?: Array<{ role: "system" | "user" | "assistant"; content: string }>; // 新增
   }): Array<{ role: "system" | "user" | "assistant"; content: string }> {
     // 如果有对话历史，合并历史消息和当前消息
     // 如果没有对话历史，使用现有逻辑
   }
   ```

3. **更新路由**：
   - `ai-service` 路由需要解析 `messages` 参数
   - `local-ai-service` 路由需要将处理后的历史传递给 `runScene`

---

## 八、相关文件清单

### 8.1 核心文件

1. **场景执行层**:
   - `apps/ai-service/src/lib/sceneRunner.ts` - 场景执行引擎（需要修改）

2. **AI服务路由层**:
   - `apps/ai-service/src/routes/ask.ts` - AI服务主路由（需要修改）
   - `apps/local-ai-service/src/routes/ask.ts` - 本地AI服务路由（需要修改）

3. **前端调用层**:
   - `src/components/AIPage.tsx` - AI聊天页面（已正确传递 messages）
   - `src/components/QuestionAIDialog.tsx` - 问题AI对话框（可能也传递了 messages）

### 8.2 相关文档

1. **架构文档**:
   - `docs/AI板块整体架构说明.md` - AI板块整体架构

2. **历史修复文档**:
   - `docs/问题修复/20251202/主程序传送语言与AI实际输出语言不符/` - 语言选择修复文档

### 8.3 数据库表

1. **场景配置表**:
   - `ai_scene_config` - 场景配置表（包含多语言 prompt）

---

## 九、后续行动建议

### 9.1 立即行动

1. **扩展接口和函数**：
   - 在 `RunSceneOptions` 中添加 `messages` 字段
   - 修改 `buildMessages` 函数，接收并处理对话历史

2. **更新路由**：
   - `ai-service` 路由需要解析 `messages` 参数
   - `local-ai-service` 路由需要将处理后的历史传递给 `runScene`

3. **测试验证**：
   - 测试多轮对话场景
   - 验证语言一致性

### 9.2 长期优化

1. **完善对话历史处理**：
   - 确保对话历史中的语言与 system prompt 语言一致
   - 优化对话历史的过滤和处理逻辑

2. **增强日志**：
   - 记录是否传递了对话历史
   - 记录对话历史的长度和内容摘要

3. **文档更新**：
   - 更新 AI 板块整体架构说明文档
   - 说明对话历史的处理方式

---

**报告结束**

