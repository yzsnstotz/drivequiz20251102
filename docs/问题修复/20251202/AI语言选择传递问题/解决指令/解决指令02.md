0. 任务范围声明（必须写在最前面）

本次任务只允许修改主程序（web / Next.js）代码，严格禁止修改以下目录任何文件：

apps/ai-service/**

apps/local-ai-service/**

ai-service 当前不做语言逻辑，本次只要求「主程序发送的请求里带对的语言」。

1. 问题现状 & 目标（让 Cursor 先打印一段摘要）

请 Cursor 在执行前先打印类似摘要：

当前现象（用户复测）：

语言页面选择 English / 日本語 后，进入 AI 对话页发送第一条消息时，ai-service 日志里看到的 locale 仍然是 'zh'（或者 'zh-CN' → zh）。

目标：

修复主程序的语言传递链路，确保：

LanguageContext 读到的是用户实际选择的语言（zh/en/ja）；

对话页在发请求前拿到的 language 不再是 'zh'；

callAiDirect 发出去的 locale 字段能反映真实语言（比如 en-US / ja-JP）；

不修改 apps/ai-service 任何文件。

2. 第一步：统一「localStorage 键名」& 语言上下文

文件：

src/contexts/LanguageContext.tsx

语言选择页面（例如 /src/components/LanguageSelector.tsx 或 /src/app/language/page.tsx，以实际项目为准）

2.1 确认并统一 localStorage key

在项目中搜索 localStorage.setItem(，找到用户选择语言时写入 localStorage 的地方，确认使用的 key 是什么：

诊断报告里是 user-language。

在 LanguageContext.tsx 中找到 LANGUAGE_STORAGE_KEY 常量（或类似名字）。

要求：

保证 LanguageContext 读取的 key 和 语言选择页面写入的 key 完全一致。

如果不一致（比如一边是 'user-language'，另一边是 'drivequiz-language'），必须统一为同一个常量 LANGUAGE_STORAGE_KEY。

修改要求：

把硬编码的字符串 key 全部改为从 LANGUAGE_STORAGE_KEY 读取；

所有写入和读取语言的地方都用同一个常量。

2.2 确认 LanguageContext 真正是 client 组件

重点：这一步只动主程序，不动 ai-service。

在 src/contexts/LanguageContext.tsx 顶部：

如果没有 'use client';：

在文件第一行添加：

'use client';


然后检查 LanguageProvider 是不是只在 client component 里使用：

如果 LanguageProvider 被放在 app/layout.tsx 这种 server component 里，需要由 Cursor 检查项目结构：

找到 LanguageProvider 的使用点；

确认这些使用点本身是否已标记 'use client'；

如果不是，需要 Cursor 按项目规范处理（一般是在子 layout 或 page 里包一层 client 组件）。

目标：保证 LanguageContext 和 getInitialLanguage 这一套逻辑只在浏览器端执行，不受 SSR 初始值 'zh' 影响。

3. 第二步：改造 LanguageContext 初始化 + 加就绪标记

文件： src/contexts/LanguageContext.tsx

当前报告里 Cursor 改成了：useState(getInitialLanguage) + useEffect 只设 mounted。

但你实际测试还是 zh，风险很可能在：

SSR 时初始化为 'zh'；

或 localStorage key 不一致；

或对话页在语言「还没准备好」的时候就发送了第一条消息。

这一步要求 Cursor 这样改：

3.1 保留 getInitialLanguage，但增加 languageReady

确保 getInitialLanguage 使用统一 key：

const getInitialLanguage = (): Language => {
  if (typeof window === 'undefined') return 'zh';

  const saved = localStorage.getItem(LANGUAGE_STORAGE_KEY) as Language | null;
  if (saved && ['zh', 'en', 'ja'].includes(saved)) return saved;

  const browserLang = navigator.language || navigator.languages?.[0] || 'zh';
  if (browserLang.startsWith('ja')) return 'ja';
  if (browserLang.startsWith('en')) return 'en';

  return 'zh';
};


新增一个「语言是否就绪」的 state：

const [language, setLanguageState] = useState<Language>(getInitialLanguage);
const [languageReady, setLanguageReady] = useState(false);

useEffect(() => {
  setLanguageReady(true);
}, []);


在 Context 对外暴露时，新增 languageReady：

const value: LanguageContextType = {
  language,
  setLanguage: updateLanguage,
  t,
  languageReady,
};


如果当前 LanguageContextType 没有 languageReady，请更新类型定义，同时保证现有调用方不报错（可以先全局搜索 useLanguage( 看调用处）。

确保 setLanguage（或者 updateLanguage）在切换语言时同步写入 localStorage：

const updateLanguage = useCallback((next: Language) => {
  setLanguageState(next);
  if (typeof window !== 'undefined') {
    localStorage.setItem(LANGUAGE_STORAGE_KEY, next);
  }
}, []);

4. 第三步：在对话页禁止「语言未就绪就发送」

文件： src/components/AIPage.tsx（或实际承载对话逻辑的组件）

诊断报告显示这个组件是主链路：useLanguage() → languageToLocale(language) → callAiDirect({... locale })。

4.1 引用 languageReady 并在 handleSend 里加保护

在对话组件里，用 useLanguage() 获取 languageReady：

const { t, language, languageReady } = useLanguage();


在 handleSend 最前面加保护逻辑：

const handleSend = useCallback(async () => {
  if (!languageReady) {
    console.warn('[lang-trace] blocked send: language not ready yet');
    return;
  }

  // ... 原来的校验 & 发送逻辑
}, [
  languageReady,
  /* 其他依赖保持不变 */
]);


同时，可以在发送按钮上加 disabled 条件（可选，但建议）：

<Button
  onClick={handleSend}
  disabled={!languageReady || loading || !input.trim()}
>
  发送
</Button>


这样可以彻底避免「LanguageContext 还没准备好，语言仍是 zh，就发出第一条请求」的问题。

5. 第四步：只在主程序打日志（不改 ai-service）

文件：

src/contexts/LanguageContext.tsx

src/components/AIPage.tsx

src/lib/aiClient.front.ts

（若存在）src/app/api/ai/**/route.ts 这种 Next.js API 路由

5.1 LanguageContext 日志

在 LanguageProvider 渲染时，加一条调试日志（开发环境）：

useEffect(() => {
  console.log('[lang-trace] LanguageProvider mounted', {
    initialLanguage: language,
  });
}, [language]);

5.2 AIPage / 对话组件日志

在 handleSend 里，在真正调用 callAiDirect 之前，打印：

const userLocale = languageToLocale(language);

console.log('[lang-trace] handleSend', {
  language,
  languageReady,
  userLocale,
  question: input,
});

5.3 aiClient.front.ts 日志（主程序内）

在 callAiDirect 里，不改业务，只加日志（这是主程序代码，不是 ai-service）：

export async function callAiDirect(params: AiClientRequest): Promise<AiClientResponse> {
  const { locale, ...rest } = params;
  const langFromLocale = localeToLang(locale);

  console.log('[lang-trace] callAiDirect', {
    inputLocale: locale,
    resolvedLang: langFromLocale,
    scene: rest.scene,
  });

  // 保持原有请求逻辑不变
  // ...
}


注意：不要修改 apps/ai-service 中的任何日志或逻辑。只允许改 src/lib/aiClient.front.ts（这是主程序）。

5.4 若有 BFF 路由（可选）

如果主程序里还有 /api/ai/... 这种 Next.js 路由，会在那里面再转发到 ai-service：

允许在这些 Next.js 路由里增加 console.log / logger 打点；

但这些仍然属于主程序范围，可以修改；

仍然保持「不修改 apps/ai-service」。

6. 第五步：只验证主程序发送的语言（不依赖 ai-service 日志）

这一步要求 Cursor 在本地做两组最小测试，并把结果写进新的执行报告里（比如 CP-20251202-001_语言选择传递问题_执行报告_v2.md）：

6.1 测试用例

场景 A：英语

清理浏览器 localStorage 中和语言相关的键；

进入语言设置页，选择 English；

刷新页面 → 进入 AI 对话页 /ai；

不切语言，直接输入一条 "test" 并发送；

观察浏览器控制台的 [lang-trace] 日志：

LanguageProvider initialLanguage 应为 'en'；

handleSend 里 language 应为 'en'，userLocale 应为 'en-US'；

callAiDirect 里 inputLocale 应为 'en-US'，resolvedLang 为 'en'。

在 Network 面板中选中那条 AI 请求（不管是 /ask 或 /api/ai/...），查看 Request Payload：

确认请求体里发送的 locale 字段是 'en-US' 或其它代表英文的值（不是 'zh-CN'）。

场景 B：日语

同样操作，选择 日本語；

刷新 → 进入 /ai → 发送第一条消息；

预期：

控制台日志中 language 为 'ja'，userLocale 为 'ja-JP'；

Network 里请求体的 locale 字段为 'ja-JP'；

这里的验证只看主程序发出去的请求体，不要求看 ai-service 日志。

7. 执行报告补充说明（仅主程序）

请 Cursor 在新的执行报告里明确写清：

本轮任务没有修改任何 apps/ai-service/** 文件；

通过 Network 面板确认：

场景 A：选择 English 时，首条请求体中的 locale 为英文；

场景 B：选择 日本語 时，首条请求体中的 locale 为日文；

控制台 [lang-trace] 日志中的 language / userLocale 与用户选择一致。