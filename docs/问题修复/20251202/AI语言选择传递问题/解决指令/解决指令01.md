一、指令头使用说明（必须先做）

在本次任务的最前面，先粘贴完整的《修复指令头05版（现用）.md》（指令头 v5.0），不要改动其结构。

然后再在指令头下面，粘贴「本次任务内容」＝也就是我下面写的这整段 Cursor 任务说明。

执行过程中如有涉及数据库字段/结构，仍需与 DriveQuiz 主库结构文档保持一致，但本次任务不修改任何数据库结构，只是说明清楚。

二、本次任务的「规范对齐检查摘要」（请让 Cursor 在真正动手前打印类似内容）

以下内容请 Cursor 在执行前先输出一段摘要，可按实际情况微调，但要涵盖这些要点：

🔍 已阅读规范文件：

/Users/leo/Desktop/drivequiz研发规范/🧩 AI 服务研发规范（ai-service 统一架构规范 v1.0）.md

/Users/leo/Desktop/drivequiz研发规范/🧩 AI 核心服务规范（ai-core 统一架构规范 v2.0）.md

/Users/leo/Desktop/drivequiz研发规范/JSON清洗与语言过滤规范.md

/Users/leo/Desktop/drivequiz研发规范/数据库结构_DRIVEQUIZ.md（仅确认无 DB 变更）

/Users/leo/Desktop/drivequiz研发规范/数据库结构_AI_SERVICE.md

/Users/leo/Desktop/drivequiz研发规范/文件结构.md

📘 本任务约束条款：A1（路由层不能放业务）、B1/B3/B4（DB 文档与 Kysely 类型保持一致，但本次无 schema 变更）、C1–C3（AI 调用双环境测试）、D1–D2（必须输出执行报告）。

📌 强关联条款：A1、C1、C2、D1。

📁 预计影响文件：

src/contexts/LanguageContext.tsx

src/components/AIPage.tsx

src/lib/aiClient.front.ts

apps/ai-service/src/routes/ask.ts（仅检查 / 轻量日志，不改业务逻辑）

apps/ai-service/src/lib/sceneRunner.ts（仅确认 lang 使用正确）

src/lib/version.ts

三、任务目标（给 Cursor 的清晰目标）

从根上修复语言选择传递问题：

确保用户在前端切换语言（zh/en/ja）后，首条消息就能用正确的 lang 传到 ai-service/local-ai-service，不再因为初始化默认 'zh' 导致 AI 使用中文 prompt。

保持现有类型与 context API 不变：

Language 类型仍然是 'zh' | 'en' | 'ja'。

useLanguage() 的返回结构和使用方式保持不变，不破坏现有调用方。

保证 SSR/CSR 兼容：

SSR 时仍然安全，避免直接访问 window 导致报错。

不改数据库结构：

本问题只涉及语言选择 & 请求参数，不新增/修改任何 DB 字段或表。

补充必要日志 + 执行报告：

便于以后再排查类似问题。

四、具体修改要求（按文件分解）
1. src/contexts/LanguageContext.tsx —— 修复语言初始化的核心文件

问题回顾（来自诊断报告）：

目前 LanguageProvider 中：

const [language, setLanguageState] = useState<Language>('zh');
useEffect(() => {
  if (typeof window !== 'undefined') {
    const saved = localStorage.getItem(LANGUAGE_STORAGE_KEY) as Language | null;
    if (saved && ['zh', 'en', 'ja'].includes(saved)) {
      setLanguageState(saved);
    }
  }
}, []);


由于 useEffect 是异步执行，用户如果在页面加载后的首条消息就发送提问，language 仍然是 'zh'，导致整个链路都走中文。

1.1 实现「同步初始化语言」的 getInitialLanguage

在 LanguageProvider 内部新增一个同步函数（注意 SSR 安全）：

const getInitialLanguage = (): Language => {
  // SSR 场景：没有 window，统一返回 'zh'
  if (typeof window === 'undefined') {
    return 'zh';
  }

  // 1）优先读取本地存储的用户选择
  const saved = localStorage.getItem(LANGUAGE_STORAGE_KEY) as Language | null;
  if (saved && ['zh', 'en', 'ja'].includes(saved)) {
    return saved;
  }

  // 2）没有保存则根据浏览器语言猜测
  const browserLang = navigator.language || navigator.languages?.[0] || 'zh';
  if (browserLang.startsWith('ja')) {
    return 'ja';
  }
  if (browserLang.startsWith('en')) {
    return 'en';
  }

  // 3）兜底：中文
  return 'zh';
};

1.2 改造 useState 初始值

把原来的：

const [language, setLanguageState] = useState<Language>('zh');


替换为：

const [language, setLanguageState] = useState<Language>(getInitialLanguage);


这样，在组件第一次渲染时就已经拿到了正确语言，不再依赖异步的 useEffect。

1.3 调整 useEffect 的职责

原来的 useEffect 里负责从 localStorage 读语言，现在这部分逻辑已经被 getInitialLanguage 同步完成，请删除 useEffect 中的「读取语言并 setState」部分。

useEffect 如仍需要 mounted 标记（例如避免水合闪烁），只保留「设置 mounted」逻辑即可，例如：

const [mounted, setMounted] = useState(false);

useEffect(() => {
  setMounted(true);
}, []);


保留现有 UI 对 mounted 的使用方式，不改变渲染分支结构（比如原来如果 !mounted 返回 null 就继续保持）。

1.4 确保语言切换时写回 localStorage

检查 LanguageContext 中暴露给外部的 setLanguage 或类似 API：

要求：当用户显式切换语言时，必须同步写入 localStorage，避免刷新后又退回默认语言。若当前没有统一包装，请新增一个包装函数：

const updateLanguage = useCallback((next: Language) => {
  setLanguageState(next);
  if (typeof window !== 'undefined') {
    localStorage.setItem(LANGUAGE_STORAGE_KEY, next);
  }
}, []);


然后把这个 updateLanguage 暴露给 LanguageContext，替换原本直接暴露的 setLanguageState（保持对外命名不变，例如仍叫 setLanguage，只是内部实现更安全）。

✅ 要点：对外 TypeScript 类型签名保持不变，只在内部实现层面增加 localStorage 写入。

2. src/components/AIPage.tsx —— 确认使用 Context 的 language 计算 locale

诊断报告中的关键片段已说明 AIPage 现在是通过 useLanguage() 拿到 language，并用 languageToLocale(language) 计算 userLocale，再传给 callAiDirect。

请在本文件中完成以下检查与修正：

确认顶部引入了 useLanguage() 和 languageToLocale，且 language 的类型为 'zh' | 'en' | 'ja'。

在 handleSend（或实际发送请求的函数）中，确保逻辑类似如下：

const { t, language } = useLanguage();

const handleSend = useCallback(async () => {
  // ... 其它校验逻辑（input 判空等）

  const userLocale = languageToLocale(language); // e.g. 'zh-CN' / 'en-US' / 'ja-JP'

  const payload = await callAiDirect({
    provider: currentProvider,
    question: q,
    locale: userLocale,
    scene: 'chat',
    // 其它参数保持不变
  });

  // ... 处理响应
}, [/* 依赖列表保持合理完整 */]);


确保 没有任何地方 再使用旧的 useUserLocale() 之类的逻辑给 AI 请求设置语言；如果有，统一替换成「language → languageToLocale → 传给 callAiDirect」这一条链路。

3. src/lib/aiClient.front.ts —— 确保 locale → lang 转换完整且稳定

诊断报告中指出，这里已经通过 localeToLang 把 'en-US' 转换为 'en'：

export async function callAiDirect(params: AiClientRequest): Promise<AiClientResponse> {
  // ...
  const lang = localeToLang(rest.locale); // 'en-US' → 'en'
  const requestBody = {
    question: rest.question,
    lang,
    scene: rest.scene,
    // ...
  };
}


请 Cursor 做以下确认与微调：

检查 localeToLang 的实现，确保至少正确处理：

'zh-CN' / 'zh' → 'zh'

'ja-JP' / 'ja' → 'ja'

'en-US' / 'en' → 'en'

对于 locale 为空或未识别的情况，统一 fallback 到 'zh'，避免出现 lang = undefined 的情况，伪代码示例：

function localeToLang(locale: string | undefined): Language {
  if (!locale) return 'zh';
  const lower = locale.toLowerCase();
  if (lower.startsWith('ja')) return 'ja';
  if (lower.startsWith('en')) return 'en';
  return 'zh';
}


确保 callAiDirect 中最终发给后端的请求体包含：

lang：'zh' | 'en' | 'ja'

不再有其它地方覆盖 lang 为固定 'zh'。

禁止事项：

不允许在这里写死 lang: 'zh' 作为默认值覆盖前端传入逻辑。

4. apps/ai-service/src/routes/ask.ts & apps/ai-service/src/lib/sceneRunner.ts —— 只做检查 & 日志增强

根据诊断报告，后端链路大致正确：

callAiDirect → POST /ask → ask.ts 解析 lang → sceneRunner 用 lang 选择对应 system_prompt。

请 Cursor 执行以下操作：

在 ask.ts 中确认：

parseAndValidateBody 返回的对象中包含 lang: string，且非空校验已经存在。

没有任何地方把 lang 强行改为 'zh'。

在不改变业务逻辑的前提下，可以增加一行简短的 debug 日志，方便以后排查，例如：

app.post('/ask', async (req, reply) => {
  const { lang, scene } = parseAndValidateBody(req.body);
  req.log.debug({ lang, scene }, '[ask] incoming request lang/scene');
  // ...
});


在 sceneRunner.ts 中确认：

lang 的值直接用于选择对应语言的配置（如 system_prompt_zh / _en / _ja），不要有「忽略 lang 直接用中文 prompt」的逻辑。

若有这种硬编码，请改为基于 lang 的分支选择；但不要改动其它与本问题无关的逻辑。

5. src/lib/version.ts —— 更新版本号 / 构建时间

按照指令头 v5.0 要求：

在 src/lib/version.ts 中更新 BUILD_TIME 为当前日期时间（ISO 字符串或项目现有格式）。

在最终执行报告中写明本次的 BUILD_TIME 值，方便以后追踪。

五、测试要求（Cursor 必须自动执行）
1. 前端功能测试（local）

请 Cursor 在本地 dev 环境完成如下测试（通过自动脚本或手动步骤 + 日志）：

场景一：默认语言 + 首条消息

清空浏览器 localStorage 中的语言相关 key。

打开页面，不切换语言，直接发送一条消息。

预期：

请求体中的 lang 为 'zh'。

ai-service/ local-ai-service 日志中看到 lang: 'zh'。

场景二：选择英文后刷新 + 首条消息

在前端语言切换组件中将语言设为英文。

确认 localStorage 中保存为 'en'。

刷新页面后立即发送一条消息（不等待）。

预期：

LanguageContext 初始值应为 'en'（可通过临时日志或 React DevTools 确认）。

发往 /ask 的请求中 lang 为 'en'。

AI 使用英文 prompt & 回复。

场景三：选择日文后刷新 + 首条消息

同样步骤，把语言切换为 'ja'，刷新后立即提问。

预期：

lang 为 'ja'。

AI 使用日文 prompt & 回复。

2. 双环境测试（C1–C3）

如项目存在本地 local-ai-service 与远程 ai-service 两种 provider：

分别以 local / remote provider 运行一次上述场景二、三。

在测试日志中分别记录请求耗时、lang 值、响应是否正常。

如果某个环境暂时不可用，需要在执行报告中写明原因与当前行为（例如：remote service 暂时关闭，只测试 local）。

六、执行报告要求（D1/D2）

本次任务完成后，请 Cursor 自动生成执行报告文件，路径固定为：

docs/问题修复/CP-20251202-001_语言选择传递问题/执行报告/CP-20251202-001_语言选择传递问题_执行报告.md


报告内容至少包括：

任务摘要

问题描述：语言选择无法正确传递，AI 一直使用中文 prompt。

根因简述：LanguageContext 初始值硬编码 'zh' + 依赖异步 useEffect 导致首条消息仍为 'zh'。

修改文件列表

src/contexts/LanguageContext.tsx（同步初始化语言 + localStorage 写入）

src/components/AIPage.tsx（确认 language → locale → callAiDirect 链路）

src/lib/aiClient.front.ts（保证 localeToLang 完整，fallback 合理）

apps/ai-service/src/routes/ask.ts（如有新增 debug 日志）

apps/ai-service/src/lib/sceneRunner.ts（如有确认/微调）

src/lib/version.ts（BUILD_TIME 更新）

红线规范自检（A1–D2）

A1：确认所有业务逻辑仍在 service/工具层，路由层仅负责参数解析和调度。

B1/B3/B4：本次无 DB 结构变更，Kysely 类型与文档保持一致。

C1–C3：说明实际执行的测试环境（local / remote）、请求示例、lang 值、是否通过。

D1/D2：确认本报告已生成且路径正确。

测试结果摘要

列出三大场景（默认/英文/日文首条消息）在不同 provider 下的实际 lang 日志与结果。

当前版本信息

BUILD_TIME 的具体值。

风险点 & 下一步建议

例如：建议后续为 AI 聊天功能增加端到端集成测试，用 lang 作为断言的一部分。