【任务名称】

AI 聊天功能 500 错误修复（仅限 web 主程序，不改 ai-service）

一、规范对齐要求（让 Cursor 在摘要里明确写出来）

在「规范对齐检查摘要」里，必须声明已阅读并受以下文档约束：

/Users/leo/Desktop/drivequiz研发规范/🧩 AI 服务研发规范（ai-service 统一架构规范 v1.0）.md

/Users/leo/Desktop/drivequiz研发规范/🧩 AI 核心服务规范（ai-core 统一架构规范 v2.0）.md

/Users/leo/Desktop/drivequiz研发规范/数据库结构_DRIVEQUIZ.md（只读参考，当前任务不改库）

/Users/leo/Desktop/drivequiz研发规范/文件结构.md

/Users/leo/Desktop/drivequiz研发规范/修复指令头05版（现用）.md（指令头 v5.x 当前版本）

并特别强调两条约束（Cursor 在摘要中务必写明）：

本任务只针对 web 主程序（Next.js app）。

禁止修改任何 ai 相关服务代码（apps/ai-service、apps/local-ai-service、ai-core 等）。如判断确实需要改 ai-service，请只在执行报告末尾提出“后续建议”，不要动代码。

红线自检重点：A1、B2、C1–C3、D1–D2、E1–E2。

二、问题简述（给 Cursor 的统一背景）

当前现象：在 AI 聊天页输入问题后，接口调用失败，浏览器端看到 500 Internal Server Error。

诊断报告已定位到主要可疑点集中在 src/lib/aiClient.front.ts 以及 Chat 页面触发逻辑：

请求体中可能包含 undefined / null 字段，序列化后导致 ai-service 抛错。

对 ai-service 返回的 非 2xx / 非 JSON 响应，当前代码在 response.json() 处直接抛出，间接导致 web 返回 500。

对 scene、question 等必需字段缺乏显式校验。

目标：

保证 web 层构造的请求体符合规范、无脏字段；

对 ai-service 返回错误时，web 不再出现 500，而是优雅降级为“前端可见的错误提示”；

严格控制日志，不引入新的冗余或重复代码。

三、具体修改任务拆解
任务 1：复现并记录当前行为（只读 + 日志整理）

在本地 npm run dev 启动 web 主应用。

进入 AI 聊天页面（AIPage，对应的 URL 由 Cursor 自行搜索 AIPage 组件确定）。

触发一次失败的 AI 聊天请求，记录：

浏览器 Network 面板中对应请求的 URL（通常是 web 自己的 API 路由，例如 /api/ai/chat 或类似名称），

请求体（Request Payload）与响应状态码 / 响应体，

Next.js 终端日志中对应的错误堆栈（尤其是 aiClient.front.ts 抛错位置）。

在执行报告中，用 5–10 行总结当前「错误链路」：
AIPage → 某个 API route → aiClient.front.ts → fetch ai-service → 500 / JSON parse error。

要求：此任务只读、不改动代码，用于帮助后面的修复有明确参照。

任务 2：修复请求体构建逻辑（防止脏字段 & scene 缺失）

目标文件：

src/lib/aiClient.front.ts（实际路径以项目为准，Cursor 自行通过搜索 callAiDirect / AiClientResponse 等定位）

修改要点：

集中构建请求体，并过滤 undefined/null：

找到负责发起请求到 ai-service 的函数（例如 callAiDirect 或类似名称）。

在发起 fetch 前，统一构造一个原始对象：

const rawBody = {
  question,
  lang: lang ?? userLocale ?? "ja", // 保底语言
  scene,                            // 从调用方传入
  maxHistory,
  messages: historyMessages,
  model: currentModel,
  provider: currentProvider,
};


使用 Object.entries 过滤掉 undefined 和 null 值，得到最终 body：

const requestBody = Object.fromEntries(
  Object.entries(rawBody).filter(([_, v]) => v !== undefined && v !== null),
);


用 JSON.stringify(requestBody) 作为 fetch 的 body。

增加基本参数校验（不改变业务，只做安全兜底）：

在发送请求前，添加轻量防御性校验：

if (!requestBody.question || typeof requestBody.question !== "string") {
  throw new Error("AI 请求缺少有效的 question 字段");
}

if (!requestBody.scene || typeof requestBody.scene !== "string") {
  throw new Error("AI 请求缺少有效的 scene 标识");
}


这类报错要在调用栈上被捕获，转成可提示给前端用户的文案（见后续任务 4）。

不要在这里直接 console.log 大量内容，避免污染日志（E1/E2）。

日志控制（只保留必要调试信息）：

如需日志，只在开发环境输出，使用：

if (process.env.NODE_ENV === "development") {
  console.debug("[aiClient] requestBody to ai-service", requestBody);
}


删除与本功能无关的陈旧调试打印、重复日志，遵守 E1/E2（清理冗余代码）。

要求：不新建重复函数，在现有请求流水线中原地重构，避免「复制一个新版本函数+保留旧函数」这种冗余模式。

任务 3：增强对 ai-service 响应的错误处理，避免 500 泄露

目标文件：

仍为 src/lib/aiClient.front.ts（集中处理 fetch 返回）

现状（根据诊断报告）：

代码大致形态为：

const data = (await response.json()) as AiClientResponse;


当 ai-service 返回 HTML 错误页 / 非 JSON / 500 时，这一行可能直接抛异常，导致 web API 路由未捕获，最终整个请求以 500 形式暴露给前端。

修改要求：

替换为先读 text、后解析 JSON 的安全模式：

const status = response.status;
const statusText = response.statusText;
const responseText = await response.text();

if (!response.ok) {
  // 在开发环境保留部分原始响应，便于排查
  if (process.env.NODE_ENV === "development") {
    console.error("[aiClient] ai-service error response", {
      status,
      statusText,
      bodyPreview: responseText.slice(0, 500),
    });
  }

  throw new Error(
    `AI service 返回错误状态：${status} ${statusText || ""}`.trim(),
  );
}

let data: AiClientResponse;
try {
  data = JSON.parse(responseText) as AiClientResponse;
} catch (error) {
  if (process.env.NODE_ENV === "development") {
    console.error("[aiClient] 解析 ai-service 响应 JSON 失败", {
      status,
      statusText,
      bodyPreview: responseText.slice(0, 500),
      error,
    });
  }
  throw new Error("无法解析 AI 服务返回的数据，请稍后重试。");
}


保证所有抛出的错误都被上游调用者捕获，而不是直接让 Next.js 路由抛出未处理异常。

不修改 AiClientResponse 类型定义，不对 ai-service 的约定结构「想当然」扩展字段，只在解析层做防御性处理。

任务 4：从 API route 到前端的错误传递链路梳理

目标文件（示例，Cursor 自行精确搜索）：

src/app/api/ai/...(chat|ask)/route.ts

src/components/AIPage.tsx

修改目标：

API route 层（Next.js App Router 的 route.ts）：

捕获来自 aiClient 的异常，统一转换为结构化 JSON 错误，而不是让异常直接冒泡为 500。

示例伪代码（按实际文件名自行调整）：

import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const result = await callAiDirect({
      question: body.question,
      // ...其他字段
    });

    return NextResponse.json(result);
  } catch (error: any) {
    console.error("[api/ai/chat] 调用 aiClient 失败", {
      message: error?.message,
    });

    return NextResponse.json(
      {
        ok: false,
        error: error?.message ?? "AI 服务调用失败",
      },
      { status: 502 }, // 用 502/500 皆可，但要统一
    );
  }
}


注意：不要在这里构造 OpenAI 请求、不要直接调用 ai-service，这一层只调用 aiClient（符合 A1）。

前端组件 AIPage：

调用 API route 时，对非 2xx 响应用统一错误文案提示，而不是依赖浏览器默认错误。

确保用户界面看到的是友好的错误提示，例如「AI 服务暂时不可用，请稍后重试」，而不是空白或崩溃。

如果当前已经有错误状态管理（如 setError state），复用它即可，不要复制一套新的状态逻辑。

任务 5：双环境验证 + 日志摘要

在本地环境下，分别测试（如果当前 web 支持切换 provider）：

连接远程 ai-service（Render），确认：

不再出现前端 500，

当 ai-service 实际返回错误时，用户能收到明确的错误提示。

如仍然接入 local-ai-service 测试通路（如果主服务仍支持），确认行为一致（符合 C1–C3）。

在执行报告中整理：

测试用例（例如：正常问题、异常场景、网络故障模拟等），

对应的 Network 截图 / 状态码 / 返回体摘要，

日志中关键错误被控制在 aiClient / API route，而非顶层崩溃。

任务 6：版本号与文档

按规范修改 src/lib/version.ts 中的 BUILD_TIME 为当前实际时间（ISO 字符串），并在执行报告中写明当前版本号（例如 2025-12-02T05:30:00+09:00 这一类）。

本次任务不改数据库 schema，也不改 AI service / local-ai-service / ai-core，因此：

不允许 新建或修改数据库迁移脚本；

不允许 修改 /Users/leo/Desktop/drivequiz研发规范/数据库结构_DRIVEQUIZ.md 或 /数据库结构_AI_SERVICE.md。

四、执行报告要求（按模板输出）

在以下路径新增/更新执行报告（文件名自行按任务命名）：

docs/问题修复/CP-20251202-012_AI聊天500错误/执行报告/AI聊天500_修复_执行报告.md

报告至少包含：

任务摘要（简要说明问题 & 修复思路）；

修改文件列表（精确到文件路径）；

红线规范 A1–D2 & E1–E2 自检表（逐条标注：已遵守 / 不适用）；

主要代码改动说明（用文字 + 必要的关键代码片段）；

测试结果（包括远程 ai-service 的测试情况）；

风险点 & 下一步建议：

若发现问题根源确实在 ai-service 配置（如某 scene 不存在），只能在此处提出后续建议，不要在本任务中修改 ai-service 代码。