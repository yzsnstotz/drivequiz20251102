# 429错误处理分析报告

## 1. 当前方法的目的

### 1.1 单一题目翻译调用流程

以**单一题目翻译**为例，系统通过以下流程调用AI Provider：

```
translateWithPolish (翻译入口)
  ↓
callAiAskInternal (内部AI调用，带重试机制)
  ↓
/api/admin/ai/ask (后台管理接口)
  ↓
callAiServiceCore (AI服务核心)
  ↓
callGeminiDirect (Google Gemini直连调用)
```

### 1.2 核心目的

**`callAiAskInternal`** 函数的主要目的：
- 为批量处理场景提供**统一的AI调用接口**
- 通过**管理员token**跳过用户配额限制
- 实现**429速率限制错误的自动重试机制**
- 通过**请求队列**确保同一时间只有一个AI请求在执行，避免并发导致的速率限制

**`translateWithPolish`** 函数的主要目的：
- 将题目的内容、选项、解释等组合成完整的翻译请求
- 调用AI Provider进行翻译
- 解析AI返回的JSON格式响应
- 处理JSON截断等异常情况

---

## 2. 实现逻辑和关键方法体

### 2.1 请求队列机制（AiRequestQueue）

```42:92:src/app/api/admin/question-processing/_lib/batchProcessUtils.ts
// 全局 AI 请求队列：确保同一时间只有一个 AI 请求在进行
class AiRequestQueue {
  private queue: Array<() => Promise<any>> = [];
  private processing = false;
  private requestId = 0;

  async enqueue<T>(fn: () => Promise<T>): Promise<T> {
    const currentRequestId = ++this.requestId;
    const queueLength = this.queue.length;
    
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          if (queueLength > 0) {
            console.log(`[AiRequestQueue] [Request ${currentRequestId}] 等待队列中，前面还有 ${queueLength} 个请求`);
          }
          console.log(`[AiRequestQueue] [Request ${currentRequestId}] 开始处理 AI 请求`);
          const result = await fn();
          console.log(`[AiRequestQueue] [Request ${currentRequestId}] ✅ AI 请求完成`);
          resolve(result);
        } catch (error) {
          console.log(`[AiRequestQueue] [Request ${currentRequestId}] ❌ AI 请求失败:`, error instanceof Error ? error.message : String(error));
          reject(error);
        }
      });
      this.process();
    });
  }

  private async process() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;
    console.log(`[AiRequestQueue] 开始处理队列，当前队列长度: ${this.queue.length}`);

    while (this.queue.length > 0) {
      const task = this.queue.shift();
      if (task) {
        await task();
      }
    }

    this.processing = false;
    console.log(`[AiRequestQueue] 队列处理完成`);
  }
}

// 创建全局队列实例
const aiRequestQueue = new AiRequestQueue();
```

**作用**：通过队列机制，确保所有AI请求串行执行，避免并发请求导致429错误。

---

### 2.2 核心调用方法：callAiAskInternal

```135:366:src/app/api/admin/question-processing/_lib/batchProcessUtils.ts
async function callAiAskInternal(params: {
  question: string;
  locale?: string;
  scene?: string;
  sourceLanguage?: string;
  targetLanguage?: string;
  adminToken?: string; // 管理员 token，必需
}, retries: number = 5): Promise<{ answer: string; aiProvider?: string; model?: string }> { // 增加重试次数到5次，返回更多信息
  // 管理员 token 是必需的
  if (!params.adminToken) {
    throw new Error("Admin token is required for batch processing");
  }

  // 在 Vercel 环境中，使用绝对 URL
  // 优先使用 VERCEL_URL（Vercel 自动提供），否则使用 NEXT_PUBLIC_APP_URL
  let baseUrl = process.env.VERCEL_URL || process.env.NEXT_PUBLIC_APP_URL;
  
  // 如果是在 Vercel 环境中，构建完整 URL
  if (baseUrl) {
    if (!baseUrl.startsWith("http")) {
      baseUrl = `https://${baseUrl}`;
    }
  } else {
    // 本地开发环境，使用 localhost
    baseUrl = "http://localhost:3000";
  }

  // 使用后台接口
  const apiUrl = `${baseUrl}/api/admin/ai/ask`;

  // 内部调用（使用 fetch），带重试机制
  // 设置总体超时时间（根据场景调整）
  // 对于批量处理，需要更长的超时时间，因为可能涉及多个操作
  const isBatchProcessing = process.env.VERCEL_ENV === 'preview' || process.env.VERCEL_ENV === 'production';
  const overallTimeout = isBatchProcessing ? 250000 : 55000; // 批量处理：250秒，单次调用：55秒
  
  // 将整个重试逻辑（包括所有重试）放入队列，确保同一时间只有一个 AI 请求在执行
  // 这样即使第一次请求失败需要重试，也不会立即发起第二次请求
  return await aiRequestQueue.enqueue(async () => {
    const startTime = Date.now();
    
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        // 检查是否已经超过总体超时时间
        const elapsed = Date.now() - startTime;
        if (elapsed > overallTimeout) {
          throw new Error(`AI API call timeout: exceeded ${overallTimeout}ms total time`);
        }
        
        // 为每次请求设置超时（根据场景调整）
        // 批量处理场景需要更长的超时时间，因为AI可能需要更长时间处理
        const singleRequestTimeout = isBatchProcessing ? 120000 : 30000; // 批量处理：120秒，单次调用：30秒
        
        // 构建请求头，管理员 token 是必需的
        const headers: Record<string, string> = {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${params.adminToken}`,
        };

        // 执行单个请求（不再嵌套队列，因为整个重试逻辑已经在队列中）
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), singleRequestTimeout);
        
        let response: Response;
        try {
          response = await fetch(apiUrl, {
            method: "POST",
            headers,
            body: JSON.stringify({
              question: params.question,
              locale: params.locale || "zh-CN",
              scene: params.scene,
              sourceLanguage: params.sourceLanguage,
              targetLanguage: params.targetLanguage,
            }),
            signal: controller.signal,
          });
          clearTimeout(timeoutId);
        } catch (error) {
          clearTimeout(timeoutId);
          throw error;
        }

      if (!response.ok) {
        const errorText = await response.text();
        let errorData: any = null;
        try {
          errorData = errorText ? JSON.parse(errorText) : null;
        } catch {
          // 忽略JSON解析错误
        }
        
        // 检查是否是速率限制错误（包括429状态码和RATE_LIMIT_EXCEEDED错误码）
        // 注意：callGeminiDirect 现在会将429错误直接返回，不再内部重试
        const isRateLimitError = response.status === 429 || 
            errorData?.errorCode === "RATE_LIMIT_EXCEEDED" ||
            errorData?.errorCode === "PROVIDER_ERROR" && (
              errorData?.message?.includes("429") ||
              errorData?.message?.includes("Too Many Requests")
            ) ||
            errorData?.message?.includes("Daily ask limit exceeded") ||
            errorData?.message?.includes("429") ||
            errorText?.includes("429") ||
            errorText?.includes("Too Many Requests") ||
            errorText?.includes("Daily ask limit exceeded");
        
        if (isRateLimitError && attempt < retries) {
          // 检查剩余时间是否足够重试
          const elapsed = Date.now() - startTime;
          const remainingTime = overallTimeout - elapsed;
          // 对于速率限制错误，使用更长的延迟（指数退避，但批量处理时使用更长的延迟）
          const baseDelay = isBatchProcessing ? Math.pow(2, attempt) * 2000 : Math.pow(2, attempt) * 1000;
          const delay = Math.min(baseDelay, remainingTime - 5000);
          
          if (delay < 1000) {
            // 如果剩余时间不足1秒，直接失败
            throw new Error(`AI API call timeout: insufficient time for retry (remaining: ${remainingTime}ms)`);
          }
          
          console.log(`[callAiAskInternal] 速率限制错误，等待 ${delay}ms 后重试 (尝试 ${attempt}/${retries})`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        throw new Error(`AI API call failed: ${response.status} ${errorText.substring(0, 200)}`);
      }

      const data = await response.json();

      if (!data.ok) {
        // 检查速率限制错误（包括RATE_LIMIT_EXCEEDED错误码和Daily ask limit exceeded消息）
        // 注意：callGeminiDirect 现在会将429错误直接返回，不再内部重试
        const isRateLimitError = data.errorCode === "RATE_LIMIT_EXCEEDED" ||
            (data.errorCode === "PROVIDER_ERROR" && (
              data.message?.includes("429") ||
              data.message?.includes("Too Many Requests")
            )) || 
            data.message?.includes("429") || 
            data.message?.includes("Too Many Requests") ||
            data.message?.includes("Daily ask limit exceeded");
        
        // 统一匹配所有 AI provider 的空答案错误（OpenRouter、OpenAI、Gemini、Local等）
        const isEmptyAnswerError = data.errorCode === "PROVIDER_ERROR" && 
            (data.message?.includes("empty answer") || 
             data.message?.includes("returned empty answer") ||
             data.message?.includes("Google Gemini API returned empty answer") ||
             data.message?.includes("AI service") && data.message?.includes("returned empty answer"));
        
        if ((isRateLimitError || isEmptyAnswerError) && attempt < retries) {
          // 检查剩余时间是否足够重试
          const elapsed = Date.now() - startTime;
          const remainingTime = overallTimeout - elapsed;
          // 对于速率限制错误，使用更长的延迟；对于空答案错误，使用标准延迟
          const baseDelay = isRateLimitError && isBatchProcessing 
            ? Math.pow(2, attempt) * 2000  // 速率限制：批量处理时使用更长的延迟
            : Math.pow(2, attempt) * 1000;  // 空答案或其他错误：标准延迟
          const delay = Math.min(baseDelay, remainingTime - 5000);
          
          if (delay < 1000) {
            throw new Error(`AI API call timeout: insufficient time for retry (remaining: ${remainingTime}ms)`);
          }
          
          const errorType = isRateLimitError ? "速率限制" : "空答案";
          console.log(`[callAiAskInternal] ${errorType}错误，等待 ${delay}ms 后重试 (尝试 ${attempt}/${retries})`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        throw new Error(data.message || "AI call failed");
      }

      return { 
        answer: data.data.answer,
        aiProvider: data.data.aiProvider,
        model: data.data.model,
      };
    } catch (error: any) {
      // 如果是最后一次尝试，抛出错误
      if (attempt === retries) {
        throw error;
      }
      
      // 检查是否是可重试的错误（包括速率限制、空答案、网络错误等）
      const isRetryableError = 
          error.message?.includes("429") || 
          error.message?.includes("RATE_LIMIT_EXCEEDED") ||
          error.message?.includes("Daily ask limit exceeded") ||
          error.message?.includes("rate limit") || 
          error.message?.includes("Too Many Requests") || 
          error.message?.includes("empty answer") ||
          error.message?.includes("returned empty answer") ||
          error.message?.includes("Google Gemini API returned empty answer") ||
          (error.message?.includes("AI service") && error.message?.includes("returned empty answer")) ||
          error.name === "AbortError";
      
      if (isRetryableError) {
        // 检查剩余时间是否足够重试
        const elapsed = Date.now() - startTime;
        const remainingTime = overallTimeout - elapsed;
        // 对于速率限制错误，使用更长的延迟
        // 注意：callGeminiDirect 现在会将429错误直接返回，不再内部重试
        const isRateLimit = error.message?.includes("429") || 
                           error.message?.includes("RATE_LIMIT_EXCEEDED") ||
                           error.message?.includes("Daily ask limit exceeded") ||
                           error.message?.includes("Too Many Requests");
        const baseDelay = isRateLimit && isBatchProcessing 
          ? Math.pow(2, attempt) * 2000  // 速率限制：批量处理时使用更长的延迟
          : Math.pow(2, attempt) * 1000;  // 其他错误：标准延迟
        const delay = Math.min(baseDelay, remainingTime - 5000);
        
        if (delay < 1000 || attempt === retries) {
          throw error; // 如果剩余时间不足或已经是最后一次尝试，直接抛出错误
        }
        
        const errorType = error.message?.includes("empty answer") || error.message?.includes("returned empty answer") 
          ? "空答案" 
          : error.message?.includes("429") || error.message?.includes("RATE_LIMIT_EXCEEDED") || error.message?.includes("Daily ask limit exceeded")
          ? "速率限制"
          : "网络";
        console.log(`[callAiAskInternal] ${errorType}错误，等待 ${delay}ms 后重试 (尝试 ${attempt}/${retries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      // 其他错误直接抛出
      throw error;
    }
  }
  
  throw new Error("AI API call failed after retries");
  });
}
```

**关键逻辑**：
1. **队列化执行**：所有请求通过 `aiRequestQueue.enqueue` 串行执行
2. **429错误检测**：多层级检测429错误（HTTP状态码、错误码、错误消息）
3. **指数退避重试**：
   - 批量处理：`2^attempt * 2000ms`（2秒、4秒、8秒...）
   - 单次调用：`2^attempt * 1000ms`（1秒、2秒、4秒...）
4. **超时控制**：
   - 总体超时：批量处理250秒，单次调用55秒
   - 单次请求超时：批量处理120秒，单次调用30秒
5. **重试次数**：默认5次

---

### 2.3 底层AI Provider调用：callGeminiDirect

```777:1045:src/app/api/ai/_lib/aiServiceCore.ts
/**
 * 调用 Google Gemini 直连模式
 */
async function callGeminiDirect(params: {
  question: string;
  locale?: string;
  scene?: string;
  sourceLanguage?: string;
  targetLanguage?: string;
  requestId: string;
  timeout?: number;
}): Promise<AiServiceResponse> {
  const { question, locale = "zh-CN", scene, sourceLanguage, targetLanguage, requestId, timeout = 30000 } = params;

  if (!GEMINI_API_KEY) {
    return {
      ok: false,
      errorCode: "INTERNAL_ERROR",
      message: "GEMINI_API_KEY is not set.",
    };
  }

  const geminiBaseUrl = GEMINI_BASE_URL;

  // 从数据库读取模型配置
  let model: string | null = null;
  try {
    const modelRow = await (aiDb as any)
      .selectFrom("ai_config")
      .select(["value"])
      .where("key", "=", "model")
      .executeTakeFirst();
    if (modelRow && modelRow.value && modelRow.value.trim()) {
      model = modelRow.value.trim();
    }
  } catch (e) {
    console.warn(`[${requestId}] [callGeminiDirect] 读取模型配置失败:`, (e as Error).message);
  }

  if (!model) {
    return {
      ok: false,
      errorCode: "INTERNAL_ERROR",
      message: "Google Gemini model is not configured.",
    };
  }

  // 模型名称映射
  const modelMapping: Record<string, string> = {
    "gemini-pro": "gemini-2.5-flash",
    "gemini-pro-1.5": "gemini-2.5-flash",
    "gemini-1.5-flash": "gemini-2.5-flash",
    "gemini-1.5-pro": "gemini-2.5-pro",
  };
  if (modelMapping[model]) {
    model = modelMapping[model];
  }

  // 安全审查
  const safetyCheck = checkSafetySimple(question);
  if (!safetyCheck.pass) {
    return {
      ok: false,
      errorCode: "FORBIDDEN",
      message: safetyCheck.reason || "Content blocked by safety policy",
    };
  }

  // 构建系统提示
  const lang = locale || "zh";
  const sysPrompt = await buildSystemPrompt(lang, scene, requestId, sourceLanguage, targetLanguage);
  const userPrefix = lang === "ja" ? "質問：" : lang === "en" ? "Question:" : "问题：";
  const refPrefix = lang === "ja" ? "関連参照：" : lang === "en" ? "Related references:" : "相关参考资料：";

  const geminiUrl = `${geminiBaseUrl}/models/${model}:generateContent?key=${GEMINI_API_KEY}`;

  const geminiBody = {
    contents: [
      {
        parts: [
          {
            text: `${sysPrompt}\n\n${userPrefix} ${question}\n\n${refPrefix}\n（無/None）`,
          },
        ],
      },
    ],
    generationConfig: {
      temperature: 0.4,
      maxOutputTokens: ANSWER_CHAR_LIMIT * 2,
    },
  };

  const geminiHeaders: Record<string, string> = {
    "Content-Type": "application/json",
  };

  // 重试机制：只重试网络错误和5xx错误，429错误由上层统一处理
  // 这样可以避免嵌套重试，统一由 callAiAskInternal 处理所有重试逻辑
  const maxRetries = 2; // 减少重试次数，因为429错误不再重试
  let lastError: any = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(geminiUrl, {
        method: "POST",
        headers: geminiHeaders,
        body: JSON.stringify(geminiBody),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text().catch(() => "");
        let errorDetails: any = {};
        try {
          errorDetails = JSON.parse(errorText);
        } catch {
          errorDetails = { raw: errorText };
        }

        // 429错误直接返回，由上层统一处理重试
        if (response.status === 429) {
          const errorMessage = errorDetails.error?.message || errorText;
          return {
            ok: false,
            errorCode: "PROVIDER_ERROR",
            message: `Google Gemini API error: 429 Too Many Requests${errorMessage ? ` - ${errorMessage}` : ""}`,
          };
        }

        // 如果是5xx错误，进行重试（这些是临时性的服务器错误）
        if (response.status >= 500 && attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000;
          console.log(`[${requestId}] [callGeminiDirect] 5xx错误，等待 ${delay}ms 后重试 (尝试 ${attempt}/${maxRetries})`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }

        if (response.status === 401 || response.status === 403) {
          const errorMessage = errorDetails.error?.message || errorText;
          return {
            ok: false,
            errorCode: "AUTH_REQUIRED",
            message: `Google Gemini API 认证失败: ${errorMessage}`,
          };
        }

        if (response.status === 404) {
          const errorMessage = errorDetails.error?.message || errorText;
          return {
            ok: false,
            errorCode: "PROVIDER_ERROR",
            message: `Google Gemini API 404 错误: 模型 "${model}" 未找到。${errorMessage}`,
          };
        }

        return {
          ok: false,
          errorCode: "PROVIDER_ERROR",
          message: `Google Gemini API error: ${response.status} ${response.statusText}`,
        };
      }

      const geminiData = await response.json() as {
        candidates?: Array<{ content?: { parts?: Array<{ text?: string }> } }>;
        usageMetadata?: { promptTokenCount?: number; candidatesTokenCount?: number };
      };

      // 添加详细日志，帮助调试空答案问题
      if (!geminiData.candidates || geminiData.candidates.length === 0) {
        console.error(`[${requestId}] [callGeminiDirect] Gemini API 响应中没有 candidates`, {
          hasCandidates: !!geminiData.candidates,
          candidatesLength: geminiData.candidates?.length || 0,
          responseKeys: Object.keys(geminiData),
          fullResponse: JSON.stringify(geminiData, null, 2).substring(0, 500),
        });
        return {
          ok: false,
          errorCode: "PROVIDER_ERROR",
          message: "Google Gemini API returned empty answer (no candidates)",
        };
      }

      const answer = geminiData.candidates[0]?.content?.parts?.[0]?.text?.trim() || "";
      if (!answer) {
        console.error(`[${requestId}] [callGeminiDirect] Gemini API 响应中 answer 为空`, {
          hasCandidates: !!geminiData.candidates,
          candidatesLength: geminiData.candidates.length,
          hasContent: !!geminiData.candidates[0]?.content,
          hasParts: !!geminiData.candidates[0]?.content?.parts,
          partsLength: geminiData.candidates[0]?.content?.parts?.length || 0,
          hasText: !!geminiData.candidates[0]?.content?.parts?.[0]?.text,
          textLength: geminiData.candidates[0]?.content?.parts?.[0]?.text?.length || 0,
          fullResponse: JSON.stringify(geminiData, null, 2).substring(0, 500),
        });
        return {
          ok: false,
          errorCode: "PROVIDER_ERROR",
          message: "Google Gemini API returned empty answer",
        };
      }

      const truncatedAnswer = answer.length > ANSWER_CHAR_LIMIT 
        ? answer.substring(0, ANSWER_CHAR_LIMIT) + "..."
        : answer;

      const inputTokens = geminiData.usageMetadata?.promptTokenCount || 0;
      const outputTokens = geminiData.usageMetadata?.candidatesTokenCount || 0;

      return {
        ok: true,
        data: {
          answer: truncatedAnswer,
          model: model,
          safetyFlag: "ok",
          costEstimate: {
            inputTokens,
            outputTokens,
            approxUsd: 0,
          },
          aiProvider: "gemini_direct",
        },
      };
    } catch (error: any) {
      lastError = error;
      clearTimeout(timeoutId);

      if (attempt === maxRetries) {
        break;
      }

      // 如果是网络错误或超时，进行重试
      if (error.name === "AbortError" || error.message?.includes("timeout") || error.message?.includes("network")) {
        const delay = Math.pow(2, attempt) * 1000;
        console.log(`[${requestId}] [callGeminiDirect] 网络错误，等待 ${delay}ms 后重试 (尝试 ${attempt}/${maxRetries}):`, error.message);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      throw error;
    }
  }

  // 所有重试都失败
  if (lastError) {
    if (lastError.name === "AbortError" || lastError.message?.includes("timeout")) {
      return {
        ok: false,
        errorCode: "PROVIDER_ERROR",
        message: "Google Gemini API request timeout",
      };
    }
    return {
      ok: false,
      errorCode: "PROVIDER_ERROR",
      message: `Failed to call Google Gemini API: ${lastError.message}`,
    };
  }

  return {
    ok: false,
    errorCode: "PROVIDER_ERROR",
    message: "Google Gemini API call failed after retries",
  };
}
```

**关键逻辑**：
1. **429错误直接返回**：不在此层重试，由上层 `callAiAskInternal` 统一处理
2. **只重试5xx错误和网络错误**：避免嵌套重试逻辑
3. **重试次数**：最多2次（仅针对5xx和网络错误）

---

### 2.4 翻译入口：translateWithPolish

```371:524:src/app/api/admin/question-processing/_lib/batchProcessUtils.ts
/**
 * 翻译并润色（带详细信息）
 */
export async function translateWithPolish(params: {
  source: { content: string; options?: string[]; explanation?: string };
  from: string;
  to: string;
  adminToken?: string; // 管理员 token，用于跳过配额限制
  returnDetail?: boolean; // 是否返回详细信息
}): Promise<TranslateResult | { result: TranslateResult; detail: SubtaskDetail }> {
  const { source, from, to, adminToken, returnDetail } = params;
  const questionText = [
    `Content: ${source.content}`,
    source.options && source.options.length ? `Options:\n- ${source.options.join("\n- ")}` : ``,
    source.explanation ? `Explanation: ${source.explanation}` : ``,
  ]
    .filter(Boolean)
    .join("\n");

  const sceneKey = "question_translation";
  let sceneConfig: { prompt: string; outputFormat: string | null; sceneName: string } | null = null;
  
  if (returnDetail) {
    sceneConfig = await getSceneConfig(sceneKey, to);
  }

  const data = await callAiAskInternal({
    question: questionText,
    locale: to,
    scene: sceneKey,
    sourceLanguage: from,
    targetLanguage: to,
    adminToken,
  });

  // 提取 AI provider 和 model 信息
  const aiProvider = data.aiProvider || 'unknown';
  const model = data.model || 'unknown';

  // 解析 JSON 响应
  let parsed: any = null;
  let rawAnswer = data.answer;
  
  // 尝试从代码块中提取 JSON（优先处理）
  const codeBlockMatch = rawAnswer.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (codeBlockMatch) {
    rawAnswer = codeBlockMatch[1].trim();
  }
  
  try {
    parsed = JSON.parse(rawAnswer);
  } catch (parseError) {
    // 如果 JSON 解析失败，尝试修复截断的 JSON
    try {
      let fixedJson = rawAnswer.trim();
      
      // 如果 JSON 被截断，尝试提取已有字段
      // 改进正则表达式，支持多行字符串和转义字符
      const contentMatch = fixedJson.match(/"content"\s*:\s*"((?:[^"\\]|\\.|\\n)*)"/);
      const optionsMatch = fixedJson.match(/"options"\s*:\s*\[([^\]]*)\]/);
      const explanationMatch = fixedJson.match(/"explanation"\s*:\s*"((?:[^"\\]|\\.|\\n)*)"/);
      
      if (contentMatch || optionsMatch) {
        // 至少有一个字段，尝试构建有效的 JSON
        parsed = {};
        
        if (contentMatch) {
          parsed.content = contentMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
        }
        
        if (optionsMatch) {
          try {
            // 尝试解析选项数组
            const optionsStr = optionsMatch[1];
            const options = optionsStr
              .split(',')
              .map(opt => opt.trim().replace(/^"|"$/g, '').replace(/\\"/g, '"'))
              .filter(opt => opt.length > 0);
            if (options.length > 0) {
              parsed.options = options;
            }
          } catch {
            // 忽略选项解析错误
          }
        }
        
        if (explanationMatch) {
          parsed.explanation = explanationMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
        } else {
          // 如果 explanation 被截断，尝试提取部分内容
          const explanationStartMatch = fixedJson.match(/"explanation"\s*:\s*"([^"]*)/);
          if (explanationStartMatch) {
            parsed.explanation = explanationStartMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
          }
        }
        
        // 如果成功提取了至少一个字段，使用它
        if (Object.keys(parsed).length > 0) {
          console.warn(`[translateWithPolish] JSON was truncated, extracted partial data: ${Object.keys(parsed).join(', ')}`);
        } else {
          throw new Error("No valid fields extracted from truncated JSON");
        }
      } else {
        // 尝试添加缺失的闭合括号
        if (!fixedJson.endsWith("}")) {
          const openBraces = (fixedJson.match(/\{/g) || []).length;
          const closeBraces = (fixedJson.match(/\}/g) || []).length;
          const missingBraces = openBraces - closeBraces;
          if (missingBraces > 0) {
            fixedJson += "\n" + "}".repeat(missingBraces);
          }
        }
        parsed = JSON.parse(fixedJson);
      }
    } catch {
      // 如果修复后仍然失败，记录完整响应用于调试
      console.error(`[translateWithPolish] Failed to parse AI response. Full response length: ${data.answer.length}`);
      console.error(`[translateWithPolish] Response preview: ${data.answer.substring(0, 500)}`);
      throw new Error("AI translation response missing JSON body");
    }
  }
  
  if (!parsed || typeof parsed !== "object") {
    throw new Error("AI translation response missing JSON body");
  }
  
  // 验证 content 字段是否存在且非空
  const contentStr = String(parsed.content ?? "").trim();
  if (!contentStr) {
    throw new Error("AI translation response missing content field");
  }
  
  const result: TranslateResult = {
    content: contentStr,
    options: Array.isArray(parsed.options) ? parsed.options.map((s: any) => String(s)) : undefined,
    explanation: parsed.explanation ? String(parsed.explanation) : undefined,
  };

  if (returnDetail) {
    const detail: SubtaskDetail = {
      operation: "translate",
      scene: sceneKey,
      sceneName: sceneConfig?.sceneName || sceneKey,
      prompt: sceneConfig?.prompt || "",
      expectedFormat: sceneConfig?.outputFormat || null,
      question: questionText,
      answer: data.answer,
      status: "success",
      timestamp: new Date().toISOString(),
      aiProvider: aiProvider, // 添加 AI provider 信息
      model: model, // 添加 model 信息
    };
    return { result, detail };
  }

  return result;
}
```

**关键逻辑**：
1. **组装翻译请求**：将内容、选项、解释组合成完整的问题文本
2. **调用AI服务**：通过 `callAiAskInternal` 调用AI Provider
3. **解析响应**：处理JSON格式的响应，包括截断JSON的修复

---

## 3. 遇到的问题和思考理解

### 3.1 问题描述

在批量处理题目翻译时，遇到**429 Too Many Requests**错误，导致部分题目翻译失败。

### 3.2 当前实现的优点

1. **队列化执行**：通过 `AiRequestQueue` 确保请求串行执行，避免并发导致的429错误
2. **多层级429检测**：在HTTP响应、错误码、错误消息等多个层级检测429错误
3. **指数退避重试**：使用指数退避策略，逐步增加重试延迟
4. **分层错误处理**：
   - 底层（`callGeminiDirect`）：429错误直接返回，不重试
   - 上层（`callAiAskInternal`）：统一处理429错误的重试逻辑
5. **超时控制**：设置总体超时和单次请求超时，避免无限等待

### 3.3 潜在问题和思考

#### 问题1：队列机制可能导致性能瓶颈

**现状**：
- 所有AI请求通过队列串行执行
- 即使没有429错误，请求也必须排队等待

**思考**：
- **优点**：完全避免并发导致的429错误
- **缺点**：批量处理时，100个题目需要逐个处理，总耗时 = 单次耗时 × 100
- **建议**：考虑实现**动态并发控制**，根据API的速率限制动态调整并发数（例如：最多3个并发请求）

#### 问题2：429错误检测可能不够准确

**现状**：
```typescript
const isRateLimitError = response.status === 429 || 
    errorData?.errorCode === "RATE_LIMIT_EXCEEDED" ||
    errorData?.errorCode === "PROVIDER_ERROR" && (
      errorData?.message?.includes("429") ||
      errorData?.message?.includes("Too Many Requests")
    ) ||
    errorData?.message?.includes("Daily ask limit exceeded") ||
    errorData?.message?.includes("429") ||
    errorText?.includes("429") ||
    errorText?.includes("Too Many Requests") ||
    errorText?.includes("Daily ask limit exceeded");
```

**思考**：
- 检测逻辑较为宽泛，可能误判其他错误为429错误
- 字符串匹配（`includes("429")`）可能误判（例如错误消息中包含"429"但实际不是速率限制）
- **建议**：优先使用HTTP状态码和明确的错误码，字符串匹配作为兜底

#### 问题3：重试延迟可能不够灵活

**现状**：
- 批量处理：`2^attempt * 2000ms`（2秒、4秒、8秒、16秒、32秒）
- 单次调用：`2^attempt * 1000ms`（1秒、2秒、4秒、8秒、16秒）

**思考**：
- Google Gemini API的速率限制可能是**每分钟请求数**或**每秒请求数**
- 如果限制是**每分钟60次**，那么即使等待2秒，如果之前已经发送了60个请求，仍然会收到429错误
- **建议**：
  1. 解析429响应的 `Retry-After` 头（如果API提供）
  2. 根据API文档调整延迟策略
  3. 考虑实现**令牌桶算法**或**滑动窗口**来控制请求速率

#### 问题4：没有区分不同类型的速率限制

**现状**：
- 所有429错误使用相同的重试策略

**思考**：
- Google Gemini API可能有多种速率限制：
  - **RPM（每分钟请求数）**
  - **TPM（每分钟令牌数）**
  - **并发请求数**
- 不同类型的限制需要不同的处理策略
- **建议**：根据错误消息或响应头区分限制类型，采用不同的重试策略

#### 问题5：重试次数可能不够

**现状**：
- 默认重试5次
- 如果每次重试延迟为32秒（第5次），总耗时可能超过总体超时（250秒）

**思考**：
- 如果API的速率限制窗口较长（例如：每分钟60次），可能需要更多重试
- 但增加重试次数会增加总体耗时
- **建议**：
  1. 根据错误消息中的速率限制信息动态调整重试次数
  2. 如果检测到是**配额耗尽**（而非临时速率限制），应该立即失败，而不是重试

#### 问题6：缺少速率限制监控和统计

**现状**：
- 没有记录429错误的频率和模式
- 无法分析哪些时间段更容易遇到429错误

**思考**：
- 如果能够统计429错误的发生频率，可以：
  1. 优化重试策略
  2. 调整并发数
  3. 在低峰期进行批量处理
- **建议**：添加429错误的监控和统计，记录：
  - 429错误发生的时间
  - 重试次数
  - 最终是否成功
  - 使用的AI Provider和模型

### 3.4 改进建议总结

1. **实现动态并发控制**：根据API速率限制动态调整并发数，而不是完全串行
2. **优化429错误检测**：优先使用HTTP状态码和错误码，减少字符串匹配的误判
3. **解析Retry-After头**：如果API提供，使用该头来确定重试延迟
4. **区分速率限制类型**：根据不同的限制类型采用不同的处理策略
5. **添加监控和统计**：记录429错误的发生模式，用于优化策略
6. **考虑令牌桶算法**：主动控制请求速率，避免触发429错误

---

下面是日志：
 ✓ Compiled /api/admin/question-processing/translate in 422ms (947 modules)
[AdminAuth] Request received: POST http://localhost:3000/api/admin/question-processing/translate
[DB Config] ✅ SSL enabled for Supabase connection
[DB Config] Connection string (first 50 chars): postgresql://postgres.vdtnzjvmvrcdplawwiae:tcaZ6b5...
[DB Config] Pool config applied: { hasSSL: true, sslConfig: { rejectUnauthorized: false } }
[DB Pool] New client connected
[AdminAuth] Authentication successful for http://localhost:3000/api/admin/question-processing/translate, admin: admin
[API Translate] [api-translate-1763342183218-axqtw] ========== TRANSLATE API CALLED ==========
[API Translate] [api-translate-1763342183218-axqtw] Request URL: http://localhost:3000/api/admin/question-processing/translate
[API Translate] [api-translate-1763342183218-axqtw] Request method: POST
[API Translate] [api-translate-1763342183218-axqtw] Request received
[API Translate] [api-translate-1763342183218-axqtw] Body parsed: {
  questionId: undefined,
  contentHash: '3e46ef7bf28e7668e97dbdd4a852b02237ca9171b0da9317176c171a9f475534',
  from: 'zh',
  to: [ 'ja', 'en' ]
}
[API Translate] [api-translate-1763342183218-axqtw] Starting translation for 2 language(s): [ 'ja', 'en' ]
[API Translate] [api-translate-1763342183218-axqtw] ========== Translating to ja ==========
[API Translate] [api-translate-1763342183218-axqtw] Calling translateWithPolish {
  contentLength: 34,
  hasOptions: false,
  hasExplanation: false,
  from: 'zh',
  to: 'ja'
}
[AiRequestQueue] 开始处理队列，当前队列长度: 1
[AiRequestQueue] [Request 1] 开始处理 AI 请求
 ✓ Compiled /api/admin/ai/ask in 213ms (951 modules)
[admin-1763342183637-l8w3u8ndg] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:16:23.637Z'
}
[DB Config] ✅ SSL enabled for Supabase connection
[DB Config] Connection string (first 50 chars): postgresql://postgres.vdtnzjvmvrcdplawwiae:tcaZ6b5...
[DB Config] Pool config applied: { hasSSL: true, sslConfig: { rejectUnauthorized: false } }
[DB Pool] New client connected
[admin-1763342183637-l8w3u8ndg] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342183637-l8w3u8ndg] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'ja',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'ja'
}
[admin-1763342183637-l8w3u8ndg] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342183637-l8w3u8ndg] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342183637-l8w3u8ndg] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 34.335014575s.'
}
 POST /api/admin/ai/ask 502 in 2480ms
[callAiAskInternal] 速率限制错误，等待 2000ms 后重试 (尝试 1/5)
[admin-1763342187869-p8vmnfk7m] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:16:27.869Z'
}
[admin-1763342187869-p8vmnfk7m] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342187869-p8vmnfk7m] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'ja',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'ja'
}
[admin-1763342187869-p8vmnfk7m] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342187869-p8vmnfk7m] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342187869-p8vmnfk7m] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 31.636762059s.'
}
 POST /api/admin/ai/ask 502 in 676ms
[callAiAskInternal] 速率限制错误，等待 4000ms 后重试 (尝试 2/5)
[admin-1763342192555-uumfmnqbv] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:16:32.555Z'
}
[admin-1763342192555-uumfmnqbv] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342192555-uumfmnqbv] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'ja',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'ja'
}
[admin-1763342192555-uumfmnqbv] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342192555-uumfmnqbv] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342192555-uumfmnqbv] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 26.373742722s.'
}
 POST /api/admin/ai/ask 502 in 1260ms
[callAiAskInternal] 速率限制错误，等待 8000ms 后重试 (尝试 3/5)
[DB Pool] Client removed from pool
[DB Pool] Client removed from pool
[DB Pool] Client removed from pool
[DB Pool] Client removed from pool
[DB Pool] Client removed from pool
 POST /api/admin/question-processing/translate 200 in 19998ms
[admin-1763342201837-mdlykrauy] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:16:41.837Z'
}
[admin-1763342201837-mdlykrauy] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342201837-mdlykrauy] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'ja',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'ja'
}
[admin-1763342201837-mdlykrauy] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342201837-mdlykrauy] [callAiServiceCore] AI服务模式: gemini_direct
[DB Pool] Client removed from pool
[admin-1763342201837-mdlykrauy] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 17.558036451s.'
}
 POST /api/admin/ai/ask 502 in 831ms
[callAiAskInternal] 速率限制错误，等待 16000ms 后重试 (尝试 4/5)
[admin-1763342218692-mfyx7d3df] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:16:58.692Z'
}
[admin-1763342218692-mfyx7d3df] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342218692-mfyx7d3df] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'ja',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'ja'
}
[admin-1763342218692-mfyx7d3df] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342218692-mfyx7d3df] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342218692-mfyx7d3df] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 342.918158ms.'
}
 POST /api/admin/ai/ask 502 in 1170ms
[AiRequestQueue] [Request 1] ❌ AI 请求失败: AI API call failed: 502 {"ok":false,"errorCode":"PROVIDER_ERROR","message":"Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information o
[AiRequestQueue] 队列处理完成
[API Translate] [api-translate-1763342183218-axqtw] Translation to ja failed: AI API call failed: 502 {"ok":false,"errorCode":"PROVIDER_ERROR","message":"Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information o
[API Translate] [api-translate-1763342183218-axqtw] ========== Translating to en ==========
[API Translate] [api-translate-1763342183218-axqtw] Calling translateWithPolish {
  contentLength: 34,
  hasOptions: false,
  hasExplanation: false,
  from: 'zh',
  to: 'en'
}
[AiRequestQueue] 开始处理队列，当前队列长度: 1
[AiRequestQueue] [Request 2] 开始处理 AI 请求
[admin-1763342219850-nneu9jn3o] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:16:59.850Z'
}
[admin-1763342219850-nneu9jn3o] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342219850-nneu9jn3o] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'en',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'en'
}
[admin-1763342219850-nneu9jn3o] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342219850-nneu9jn3o] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342219850-nneu9jn3o] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 59.647314697s.'
}
 POST /api/admin/ai/ask 502 in 715ms
[callAiAskInternal] 速率限制错误，等待 2000ms 后重试 (尝试 1/5)
[admin-1763342222585-56g3r0o0x] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:17:02.585Z'
}
[admin-1763342222585-56g3r0o0x] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342222585-56g3r0o0x] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'en',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'en'
}
[admin-1763342222585-56g3r0o0x] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342222585-56g3r0o0x] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342222585-56g3r0o0x] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 56.947147477s.'
}
 POST /api/admin/ai/ask 502 in 707ms
[callAiAskInternal] 速率限制错误，等待 4000ms 后重试 (尝试 2/5)
[admin-1763342227303-cah85kuui] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:17:07.303Z'
}
[admin-1763342227303-cah85kuui] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342227303-cah85kuui] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'en',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'en'
}
[admin-1763342227303-cah85kuui] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342227303-cah85kuui] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342227303-cah85kuui] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 52.11616335s.'
}
 POST /api/admin/ai/ask 502 in 762ms
[callAiAskInternal] 速率限制错误，等待 8000ms 后重试 (尝试 3/5)
[admin-1763342236074-gg64eb5b0] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:17:16.074Z'
}
[admin-1763342236074-gg64eb5b0] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342236074-gg64eb5b0] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'en',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'en'
}
[admin-1763342236074-gg64eb5b0] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342236074-gg64eb5b0] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342236074-gg64eb5b0] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 43.257100662s.'
}
 POST /api/admin/ai/ask 502 in 837ms
[callAiAskInternal] 速率限制错误，等待 16000ms 后重试 (尝试 4/5)
[admin-1763342252977-sdqmhlh8x] [ADMIN AI ASK] 后台请求开始 {
  url: 'http://localhost:3000/api/admin/ai/ask',
  method: 'POST',
  timestamp: '2025-11-17T01:17:32.977Z'
}
[admin-1763342252977-sdqmhlh8x] [ADMIN AI ASK] 管理员验证通过 { adminId: 1 }
[admin-1763342252977-sdqmhlh8x] [ADMIN AI ASK] 参数校验通过 {
  questionLength: 43,
  locale: 'en',
  scene: 'question_translation',
  sourceLanguage: 'zh',
  targetLanguage: 'en'
}
[admin-1763342252977-sdqmhlh8x] [ADMIN AI ASK] 开始调用主站 AI 接口 { timeout: '250000ms', scene: 'question_translation', adminId: 1 }
[admin-1763342252977-sdqmhlh8x] [callAiServiceCore] AI服务模式: gemini_direct
[admin-1763342252977-sdqmhlh8x] [ADMIN AI ASK] 主站 AI 接口调用失败 {
  errorCode: 'PROVIDER_ERROR',
  message: 'Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/usage?tab=rate-limit. \n' +
    '* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 250, model: gemini-2.5-flash\n' +
    'Please retry in 22.676599379s.'
}
 POST /api/admin/ai/ask 502 in 4537ms
[AiRequestQueue] [Request 2] ❌ AI 请求失败: AI API call failed: 502 {"ok":false,"errorCode":"PROVIDER_ERROR","message":"Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information o
[AiRequestQueue] 队列处理完成
[API Translate] [api-translate-1763342183218-axqtw] Translation to en failed: AI API call failed: 502 {"ok":false,"errorCode":"PROVIDER_ERROR","message":"Google Gemini API error: 429 Too Many Requests - You exceeded your current quota, please check your plan and billing details. For more information o

## 4. 总结

当前实现通过**队列化执行**和**指数退避重试**机制，基本能够处理429错误。但在批量处理场景下，完全串行执行可能导致性能瓶颈。建议：

1. **短期**：优化429错误检测逻辑，减少误判
2. **中期**：实现动态并发控制，在避免429错误的同时提高处理效率
3. **长期**：添加监控和统计，根据实际数据优化重试策略

